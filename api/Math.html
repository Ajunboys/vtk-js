<!DOCTYPE html>
<html lang="en">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <title>Math | VTK.js</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://kitware.github.io/vtk-js/api/Math.html">
  <!-- Alternative links -->
  
    
      <link rel="alternative" hreflang="en" href="https://kitware.github.io/vtk-js/api/Math.html">
    
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/vtk-js/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/vtk-js/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/vtk-js/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/vtk-js/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/vtk-js/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/vtk-js/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/vtk-js/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/vtk-js/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/vtk-js/icon/mstile-144x144.png">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  <link rel="stylesheet" href="/vtk-js/css/navy.css">
  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css">
  <!-- RSS -->
  <link rel="alternate" href="/vtk-js/atom.xml" title="VTK.js">
  <!-- Open Graph -->
  <meta name="description" content="Pi() : Math.PI;Return PI.
radiansFromDegrees(degree) : radianConvert degrees to radians.
degreesFromRadians(radian) : degreeConvert radians to degrees.
round(float): intSame as Math.round().
floor(flo">
<meta property="og:type" content="website">
<meta property="og:title" content="Math">
<meta property="og:url" content="https://kitware.github.io/vtk-js/api/Math.html">
<meta property="og:site_name" content="VTK.js">
<meta property="og:description" content="Pi() : Math.PI;Return PI.
radiansFromDegrees(degree) : radianConvert degrees to radians.
degreesFromRadians(radian) : degreeConvert radians to degrees.
round(float): intSame as Math.round().
floor(flo">
<meta property="og:updated_time" content="2016-05-14T05:25:44.098Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Math">
<meta name="twitter:description" content="Pi() : Math.PI;Return PI.
radiansFromDegrees(degree) : radianConvert degrees to radians.
degreesFromRadians(radian) : degreeConvert radians to degrees.
round(float): intSame as Math.round().
floor(flo">
  <!-- Google Analytics -->
  
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/vtk-js/" id="logo">ParaViewWeb</a>
    </h1>
    <nav id="main-nav">
      <a href="/vtk-js/docs/" class="main-nav-link">Docs</a><a href="/vtk-js/api/" class="main-nav-link">API</a><a href="/vtk-js/examples/" class="main-nav-link">Examples</a>
      <a href="https://github.com/kitware/vtk-js" class="main-nav-link"><i class="fa fa-github-alt"></i></a>
      <div id="search-input-wrap">
        <div id="search-input-icon">
          <i class="fa fa-search"></i>
        </div>
        <input type="search" id="search-input" placeholder="Search...">
      </div>
    </nav>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">Math</h1>
              </header>
              <div class="article-content" itemprop="articleBody">
                <h3 id="Pi-Math-PI" class="article-heading"><a href="#Pi-Math-PI" class="headerlink" title="Pi() : Math.PI;"></a>Pi() : Math.PI;<a class="article-anchor" href="#Pi-Math-PI" aria-hidden="true"></a></h3><p>Return PI.</p>
<h3 id="radiansFromDegrees-degree-radian" class="article-heading"><a href="#radiansFromDegrees-degree-radian" class="headerlink" title="radiansFromDegrees(degree) : radian"></a>radiansFromDegrees(degree) : radian<a class="article-anchor" href="#radiansFromDegrees-degree-radian" aria-hidden="true"></a></h3><p>Convert degrees to radians.</p>
<h3 id="degreesFromRadians-radian-degree" class="article-heading"><a href="#degreesFromRadians-radian-degree" class="headerlink" title="degreesFromRadians(radian) : degree"></a>degreesFromRadians(radian) : degree<a class="article-anchor" href="#degreesFromRadians-radian-degree" aria-hidden="true"></a></h3><p>Convert radians to degrees.</p>
<h3 id="round-float-int" class="article-heading"><a href="#round-float-int" class="headerlink" title="round(float): int"></a>round(float): int<a class="article-anchor" href="#round-float-int" aria-hidden="true"></a></h3><p>Same as Math.round().</p>
<h3 id="floor-float-int" class="article-heading"><a href="#floor-float-int" class="headerlink" title="floor(float) : int"></a>floor(float) : int<a class="article-anchor" href="#floor-float-int" aria-hidden="true"></a></h3><p>Same as Math.floor().</p>
<h3 id="ceil-float-int" class="article-heading"><a href="#ceil-float-int" class="headerlink" title="ceil(float) : int"></a>ceil(float) : int<a class="article-anchor" href="#ceil-float-int" aria-hidden="true"></a></h3><p>Same as Math.ceil().</p>
<h3 id="ceilLog2" class="article-heading"><a href="#ceilLog2" class="headerlink" title="ceilLog2()"></a>ceilLog2()<a class="article-anchor" href="#ceilLog2" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="min-a-b" class="article-heading"><a href="#min-a-b" class="headerlink" title="min(a, b)"></a>min(a, b)<a class="article-anchor" href="#min-a-b" aria-hidden="true"></a></h3><p>Same as Math.min().</p>
<h3 id="max-a-b" class="article-heading"><a href="#max-a-b" class="headerlink" title="max(a, b)"></a>max(a, b)<a class="article-anchor" href="#max-a-b" aria-hidden="true"></a></h3><p>Same as Math.max().</p>
<h3 id="isPowerOfTwo-number-Boolean" class="article-heading"><a href="#isPowerOfTwo-number-Boolean" class="headerlink" title="isPowerOfTwo(number) : Boolean"></a>isPowerOfTwo(number) : Boolean<a class="article-anchor" href="#isPowerOfTwo-number-Boolean" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="nearestPowerOfTwo-number-int" class="article-heading"><a href="#nearestPowerOfTwo-number-int" class="headerlink" title="nearestPowerOfTwo(number) : int"></a>nearestPowerOfTwo(number) : int<a class="article-anchor" href="#nearestPowerOfTwo-number-int" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="factorial-n-number" class="article-heading"><a href="#factorial-n-number" class="headerlink" title="factorial(n) : number"></a>factorial(n) : number<a class="article-anchor" href="#factorial-n-number" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="binomial-m-n-int" class="article-heading"><a href="#binomial-m-n-int" class="headerlink" title="binomial(m, n) : int"></a>binomial(m, n) : int<a class="article-anchor" href="#binomial-m-n-int" aria-hidden="true"></a></h3><h3 id="beginCombination-m-n-Array-or-null" class="article-heading"><a href="#beginCombination-m-n-Array-or-null" class="headerlink" title="beginCombination(m, n) : Array or null"></a>beginCombination(m, n) : Array or null<a class="article-anchor" href="#beginCombination-m-n-Array-or-null" aria-hidden="true"></a></h3><h3 id="nextCombination-m-n-r-Boolean" class="article-heading"><a href="#nextCombination-m-n-r-Boolean" class="headerlink" title="nextCombination(m, n, r) : Boolean"></a>nextCombination(m, n, r) : Boolean<a class="article-anchor" href="#nextCombination-m-n-r-Boolean" aria-hidden="true"></a></h3><h3 id="randomSeed" class="article-heading"><a href="#randomSeed" class="headerlink" title="randomSeed()"></a>randomSeed()<a class="article-anchor" href="#randomSeed" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="getSeed" class="article-heading"><a href="#getSeed" class="headerlink" title="getSeed()"></a>getSeed()<a class="article-anchor" href="#getSeed" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="random-minValue-0-maxValue-1-Number" class="article-heading"><a href="#random-minValue-0-maxValue-1-Number" class="headerlink" title="random(minValue = 0, maxValue = 1) : Number"></a>random(minValue = 0, maxValue = 1) : Number<a class="article-anchor" href="#random-minValue-0-maxValue-1-Number" aria-hidden="true"></a></h3><h3 id="gaussian" class="article-heading"><a href="#gaussian" class="headerlink" title="gaussian()"></a>gaussian()<a class="article-anchor" href="#gaussian" aria-hidden="true"></a></h3><p>NOT IMPLEMENTED</p>
<h3 id="add-a-b-out" class="article-heading"><a href="#add-a-b-out" class="headerlink" title="add(a, b, out)"></a>add(a, b, out)<a class="article-anchor" href="#add-a-b-out" aria-hidden="true"></a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[<span class="number">3</span>] + b[<span class="number">3</span>] =&gt; out[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="subtract-a-b-out" class="article-heading"><a href="#subtract-a-b-out" class="headerlink" title="subtract(a, b, out)"></a>subtract(a, b, out)<a class="article-anchor" href="#subtract-a-b-out" aria-hidden="true"></a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[<span class="number">3</span>] - b[<span class="number">3</span>] =&gt; out[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="multiplyScalar-vec-scalar" class="article-heading"><a href="#multiplyScalar-vec-scalar" class="headerlink" title="multiplyScalar(vec, scalar) {"></a>multiplyScalar(vec, scalar) {<a class="article-anchor" href="#multiplyScalar-vec-scalar" aria-hidden="true"></a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vec[<span class="number">3</span>] * scalar =&gt; vec[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>function multiplyScalar2D(vec, scalar) {<br>  vec[0] <em>= scalar;<br>  vec[1] </em>= scalar;<br>}</p>
<p>function dot(x, y) {<br>  return x[0] <em> y[0] + x[1] </em> y[1] + x[2] * y[2];<br>}</p>
<p>function outer(x, y, out_3x3) {<br>  for (let i = 0; i &lt; 3; i++) {<br>    for (let j = 0; j &lt; 3; j++) {<br>      out_3x3[i][j] = x[i] * y[j];<br>    }<br>  }<br>}</p>
<p>function cross(x, y, out) {<br>  const Zx = x[1] <em> y[2] - x[2] </em> y[1];<br>  const Zy = x[2] <em> y[0] - x[0] </em> y[2];<br>  const Zz = x[0] <em> y[1] - x[1] </em> y[0];<br>  out[0] = Zx;<br>  out[1] = Zy;<br>  out[2] = Zz;<br>}</p>
<p>function norm(x, n = 3) {<br>  switch (n) {<br>    case 1:<br>      return Math.abs(x);<br>    case 2:<br>      return Math.sqrt(x[0] <em> x[0] + x[1] </em> x[1]);<br>    case 3:<br>      return Math.sqrt(x[0] <em> x[0] + x[1] </em> x[1] + x[2] <em> x[2]);<br>    default:<br>      {<br>        let sum = 0;<br>        for (let i = 0; i &lt; n; i++) {<br>          sum += x[i] </em> x[i];<br>        }<br>        return Math.sqrt(sum);<br>      }<br>  }<br>}</p>
<p>function normalize(x) {<br>  const den = norm(x);<br>  if (den !== 0.0) {<br>    x[0] /= den;<br>    x[1] /= den;<br>    x[2] /= den;<br>  }<br>  return den;<br>}</p>
<p>function perpendiculars(x, y, z, theta) {<br>  const x2 = x[0] <em> x[0];<br>  const y2 = x[1] </em> x[1];<br>  const z2 = x[2] * x[2];<br>  const r = Math.sqrt(x2 + y2 + z2);</p>
<p>  let dx;<br>  let dy;<br>  let dz;</p>
<p>  // transpose the vector to avoid divide-by-zero error<br>  if (x2 &gt; y2 &amp;&amp; x2 &gt; z2) {<br>    dx = 0;<br>    dy = 1;<br>    dz = 2;<br>  } else if (y2 &gt; z2) {<br>    dx = 1;<br>    dy = 2;<br>    dz = 0;<br>  } else {<br>    dx = 2;<br>    dy = 0;<br>    dz = 1;<br>  }</p>
<p>  const a = x[dx] / r;<br>  const b = x[dy] / r;<br>  const c = x[dz] / r;<br>  const tmp = Math.sqrt(a <em> a + c </em> c);</p>
<p>  if (theta !== 0) {<br>    const sintheta = Math.sin(theta);<br>    const costheta = Math.cos(theta);</p>
<pre><code>if (y) {
  y[dx] = (c * costheta - a * b * sintheta) / tmp;
  y[dy] = sintheta * tmp;
  y[dz] = (-a * costheta - b * c * sintheta) / tmp;
}

if (z) {
  z[dx] = (-c * sintheta - a * b * costheta) / tmp;
  z[dy] = costheta * tmp;
  z[dz] = (a * sintheta - b * c * costheta) / tmp;
}
</code></pre><p>  } else {<br>    if (y) {<br>      y[dx] = c / tmp;<br>      y[dy] = 0;<br>      y[dz] = -a / tmp;<br>    }</p>
<pre><code>if (z) {
  z[dx] = -a * b / tmp;
  z[dy] = tmp;
  z[dz] = -b * c / tmp;
}
</code></pre><p>  }<br>}</p>
<p>function projectVector(a, b, projection) {<br>  const bSquared = dot(b, b);</p>
<p>  if (bSquared === 0) {<br>    projection[0] = 0;<br>    projection[1] = 0;<br>    projection[2] = 0;<br>    return false;<br>  }</p>
<p>  const scale = dot(a, b) / bSquared;</p>
<p>  for (let i = 0; i &lt; 3; i++) {<br>    projection[i] = b[i];<br>  }<br>  multiplyScalar(projection, scale);</p>
<p>  return true;<br>}</p>
<p>function dot2D(x, y) {<br>  return x[0] <em> y[0] + x[1] </em> y[1];<br>}</p>
<p>function projectVector2D(a, b, projection) {<br>  const bSquared = dot2D(b, b);</p>
<p>  if (bSquared === 0) {<br>    projection[0] = 0;<br>    projection[1] = 0;<br>    return false;<br>  }</p>
<p>  const scale = dot2D(a, b) / bSquared;</p>
<p>  for (let i = 0; i &lt; 2; i++) {<br>    projection[i] = b[i];<br>  }<br>  multiplyScalar2D(projection, scale);</p>
<p>  return true;<br>}</p>
<p>function distance2BetweenPoints(x, y) {<br>  return ((x[0] - y[0]) <em> (x[0] - y[0]) + (x[1] - y[1]) </em> (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]));<br>}</p>
<p>function angleBetweenVectors(v1, v2) {<br>  const crossVect = [0, 0, 0];<br>  cross(v1, v2, crossVect);<br>  return Math.atan2(norm(cross), dot(v1, v2));<br>}</p>
<p>function gaussianAmplitude(mean, variance, position) {<br>  const distanceFromMean = Math.abs(mean - position);<br>  return 1 / (Math.sqrt(2 <em> Math.PI </em> variance)) <em> Math.exp(-(Math.pow(distanceFromMean, 2)) / (2 </em> variance));<br>}</p>
<p>function gaussianWeight(mean, variance, position) {<br>  const distanceFromMean = Math.abs(mean - position);<br>  return Math.exp(-(Math.pow(distanceFromMean, 2)) / (2 * variance));<br>}</p>
<p>function outer2D(x, y, out_2x2) {<br>  for (let i = 0; i &lt; 2; i++) {<br>    for (let j = 0; j &lt; 2; j++) {<br>      out_2x2[i][j] = x[i] * y[j];<br>    }<br>  }<br>}</p>
<p>function norm2D(x2D) {<br>  return Math.sqrt(x2D[0] <em> x2D[0] + x2D[1] </em> x2D[1]);<br>}</p>
<p>function normalize2D(x) {<br>  const den = norm2D(x);<br>  if (den !== 0.0) {<br>    x[0] /= den;<br>    x[1] /= den;<br>  }<br>  return den;<br>}</p>
<p>function determinant2x2(c1, c2) {<br>  return (c1[0] <em> c2[1] - c2[0] </em> c1[1]);<br>}</p>
<p>function LUFactor3x3(mat_3x3, index_3) {<br>  let maxI;<br>  let tmp;<br>  let largest;<br>  const scale = [0, 0, 0];</p>
<p>  // Loop over rows to get implicit scaling information<br>  for (let i = 0; i &lt; 3; i++) {<br>    largest = Math.abs(mat_3x3[i][0]);<br>    if ((tmp = Math.abs(mat_3x3[i][1])) &gt; largest) {<br>      largest = tmp;<br>    }<br>    if ((tmp = Math.abs(mat_3x3[i][2])) &gt; largest) {<br>      largest = tmp;<br>    }<br>    scale[i] = 1 / largest;<br>  }</p>
<p>  // Loop over all columns using Crout’s method</p>
<p>  // first column<br>  largest = scale[0] <em> Math.abs(mat_3x3[0][0]);<br>  maxI = 0;<br>  if ((tmp = scale[1] </em> Math.abs(mat_3x3[1][0])) &gt;= largest) {<br>    largest = tmp;<br>    maxI = 1;<br>  }<br>  if ((tmp = scale[2] * Math.abs(mat_3x3[2][0])) &gt;= largest) {<br>    maxI = 2;<br>  }<br>  if (maxI !== 0) {<br>    vtkSwapVectors3(mat_3x3[maxI], mat_3x3[0]);<br>    scale[maxI] = scale[0];<br>  }<br>  index_3[0] = maxI;</p>
<p>  mat_3x3[1][0] /= mat_3x3[0][0];<br>  mat_3x3[2][0] /= mat_3x3[0][0];</p>
<p>  // second column<br>  mat_3x3[1][1] -= mat_3x3[1][0] <em> mat_3x3[0][1];<br>  mat_3x3[2][1] -= mat_3x3[2][0] </em> mat_3x3[0][1];<br>  largest = scale[1] <em> Math.abs(mat_3x3[1][1]);<br>  maxI = 1;<br>  if ((tmp = scale[2] </em> Math.abs(mat_3x3[2][1])) &gt;= largest) {<br>    maxI = 2;<br>    vtkSwapVectors3(mat_3x3[2], mat_3x3[1]);<br>    scale[2] = scale[1];<br>  }<br>  index_3[1] = maxI;<br>  mat_3x3[2][1] /= mat_3x3[1][1];</p>
<p>  // third column<br>  mat_3x3[1][2] -= mat_3x3[1][0] <em> mat_3x3[0][2];<br>  mat_3x3[2][2] -= mat_3x3[2][0] </em> mat_3x3[0][2] + mat_3x3[2][1] * mat_3x3[1][2];<br>  index_3[2] = 2;<br>}</p>
<p>function LUSolve3x3(mat_3x3, index_3, x_3) {<br>  // forward substitution<br>  let sum = x_3[index_3[0]];<br>  x_3[index_3[0]] = x_3[0];<br>  x_3[0] = sum;</p>
<p>  sum = x_3[index_3[1]];<br>  x_3[index_3[1]] = x_3[1];<br>  x_3[1] = sum - mat_3x3[1][0] * x_3[0];</p>
<p>  sum = x_3[index_3[2]];<br>  x_3[index_3[2]] = x_3[2];<br>  x_3[2] = sum - mat_3x3[2][0] <em> x_3[0] - mat_3x3[2][1] </em> x_3[1];</p>
<p>  // back substitution<br>  x_3[2] = x_3[2] / mat_3x3[2][2];<br>  x_3[1] = (x_3[1] - mat_3x3[1][2] <em> x_3[2]) / mat_3x3[1][1];<br>  x_3[0] = (x_3[0] - mat_3x3[0][1] </em> x_3[1] - mat_3x3[0][2] * x_3[2]) / mat_3x3[0][0];<br>}</p>
<p>function linearSolve3x3(mat_3x3, x_3, y_3) {<br>  const a1 = mat_3x3[0][0];<br>  const b1 = mat_3x3[0][1];<br>  const c1 = mat_3x3[0][2];<br>  const a2 = mat_3x3[1][0];<br>  const b2 = mat_3x3[1][1];<br>  const c2 = mat_3x3[1][2];<br>  const a3 = mat_3x3[2][0];<br>  const b3 = mat_3x3[2][1];<br>  const c3 = mat_3x3[2][2];</p>
<p>  // Compute the adjoint<br>  const d1 = +determinant2x2(b2, b3, c2, c3);<br>  const d2 = -determinant2x2(a2, a3, c2, c3);<br>  const d3 = +determinant2x2(a2, a3, b2, b3);</p>
<p>  const e1 = -determinant2x2(b1, b3, c1, c3);<br>  const e2 = +determinant2x2(a1, a3, c1, c3);<br>  const e3 = -determinant2x2(a1, a3, b1, b3);</p>
<p>  const f1 = +determinant2x2(b1, b2, c1, c2);<br>  const f2 = -determinant2x2(a1, a2, c1, c2);<br>  const f3 = +determinant2x2(a1, a2, b1, b2);</p>
<p>  // Compute the determinant<br>  const det = a1 <em> d1 + b1 </em> d2 + c1 * d3;</p>
<p>  // Multiply by the adjoint<br>  const v1 = d1 <em> x_3[0] + e1 </em> x_3[1] + f1 <em> x_3[2];<br>  const v2 = d2 </em> x_3[0] + e2 <em> x_3[1] + f2 </em> x_3[2];<br>  const v3 = d3 <em> x_3[0] + e3 </em> x_3[1] + f3 * x_3[2];</p>
<p>  // Divide by the determinant<br>  y_3[0] = v1 / det;<br>  y_3[1] = v2 / det;<br>  y_3[2] = v3 / det;<br>}</p>
<p>function multiply3x3_vect3(mat_3x3, in_3, out_3) {<br>  const x = mat_3x3[0][0] <em> in_3[0] + mat_3x3[0][1] </em> in_3[1] + mat_3x3[0][2] <em> in_3[2];<br>  const y = mat_3x3[1][0] </em> in_3[0] + mat_3x3[1][1] <em> in_3[1] + mat_3x3[1][2] </em> in_3[2];<br>  const z = mat_3x3[2][0] <em> in_3[0] + mat_3x3[2][1] </em> in_3[1] + mat_3x3[2][2] * in_3[2];</p>
<p>  out_3[0] = x;<br>  out_3[1] = y;<br>  out_3[2] = z;<br>}</p>
<p>function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {<br>  const tmp = [<br>    [0, 0, 0],<br>    [0, 0, 0],<br>    [0, 0, 0],<br>  ];</p>
<p>  for (let i = 0; i &lt; 3; i++) {<br>    tmp[0][i] = a_3x3[0][0] <em> b_3x3[0][i] + a_3x3[0][1] </em> b_3x3[1][i] + a_3x3[0][2] <em> b_3x3[2][i];<br>    tmp[1][i] = a_3x3[1][0] </em> b_3x3[0][i] + a_3x3[1][1] <em> b_3x3[1][i] + a_3x3[1][2] </em> b_3x3[2][i];<br>    tmp[2][i] = a_3x3[2][0] <em> b_3x3[0][i] + a_3x3[2][1] </em> b_3x3[1][i] + a_3x3[2][2] * b_3x3[2][i];<br>  }</p>
<p>  for (let j = 0; j &lt; 3; j++) {<br>    out_3x3[j][0] = tmp[j][0];<br>    out_3x3[j][1] = tmp[j][1];<br>    out_3x3[j][2] = tmp[j][2];<br>  }<br>}</p>
<p>function multiplyMatrix(a, b, rowA, colA, rowB, colB, out_rowXcol) {<br>  // we need colA == rowB<br>  if (colA !== rowB) {<br>    vtkErrorMacro(‘Number of columns of A must match number of rows of B.’);<br>  }</p>
<p>  // output matrix is rowA<em>colB<br>  // output row<br>  for (let i = 0; i &lt; rowA; i++) {<br>    // output col<br>    for (let j = 0; j &lt; colB; j++) {<br>      out_rowXcol[i][j] = 0;<br>      // sum for this point<br>      for (let k = 0; k &lt; colA; k++) {<br>        out_rowXcol[i][j] += a[i][k] </em> b[k][j];<br>      }<br>    }<br>  }<br>}</p>
<p>function transpose3x3(in_3x3, outT_3x3) {<br>  let tmp;<br>  tmp = in_3x3[1][0];<br>  outT_3x3[1][0] = in_3x3[0][1];<br>  outT_3x3[0][1] = tmp;<br>  tmp = in_3x3[2][0];<br>  outT_3x3[2][0] = in_3x3[0][2];<br>  outT_3x3[0][2] = tmp;<br>  tmp = in_3x3[2][1];<br>  outT_3x3[2][1] = in_3x3[1][2];<br>  outT_3x3[1][2] = tmp;</p>
<p>  outT_3x3[0][0] = in_3x3[0][0];<br>  outT_3x3[1][1] = in_3x3[1][1];<br>  outT_3x3[2][2] = in_3x3[2][2];<br>}</p>
<p>function invert3x3(in_3x3, outI_3x3) {<br>  const a1 = in_3x3[0][0];<br>  const b1 = in_3x3[0][1];<br>  const c1 = in_3x3[0][2];<br>  const a2 = in_3x3[1][0];<br>  const b2 = in_3x3[1][1];<br>  const c2 = in_3x3[1][2];<br>  const a3 = in_3x3[2][0];<br>  const b3 = in_3x3[2][1];<br>  const c3 = in_3x3[2][2];</p>
<p>  // Compute the adjoint<br>  const d1 = +determinant2x2(b2, b3, c2, c3);<br>  const d2 = -determinant2x2(a2, a3, c2, c3);<br>  const d3 = +determinant2x2(a2, a3, b2, b3);</p>
<p>  const e1 = -determinant2x2(b1, b3, c1, c3);<br>  const e2 = +determinant2x2(a1, a3, c1, c3);<br>  const e3 = -determinant2x2(a1, a3, b1, b3);</p>
<p>  const f1 = +determinant2x2(b1, b2, c1, c2);<br>  const f2 = -determinant2x2(a1, a2, c1, c2);<br>  const f3 = +determinant2x2(a1, a2, b1, b2);</p>
<p>  // Divide by the determinant<br>  const det = a1 <em> d1 + b1 </em> d2 + c1 * d3;</p>
<p>  outI_3x3[0][0] = d1 / det;<br>  outI_3x3[1][0] = d2 / det;<br>  outI_3x3[2][0] = d3 / det;</p>
<p>  outI_3x3[0][1] = e1 / det;<br>  outI_3x3[1][1] = e2 / det;<br>  outI_3x3[2][1] = e3 / det;</p>
<p>  outI_3x3[0][2] = f1 / det;<br>  outI_3x3[1][2] = f2 / det;<br>  outI_3x3[2][2] = f3 / det;<br>}</p>
<p>function identity3x3(mat_3x3) {<br>  for (let i = 0; i &lt; 3; i++) {<br>    mat_3x3[i][0] = mat_3x3[i][1] = mat_3x3[i][2] = 0;<br>    mat_3x3[i][i] = 1;<br>  }<br>}</p>
<p>function determinant3x3(mat_3x3) {<br>  return mat_3x3[0][0] <em> mat_3x3[1][1] </em> mat_3x3[2][2] + mat_3x3[1][0] <em> mat_3x3[2][1] </em> mat_3x3[0][2] +<br>    mat_3x3[2][0] <em> mat_3x3[0][1] </em> mat_3x3[1][2] - mat_3x3[0][0] <em> mat_3x3[2][1] </em> mat_3x3[1][2] -<br>    mat_3x3[1][0] <em> mat_3x3[0][1] </em> mat_3x3[2][2] - mat_3x3[2][0] <em> mat_3x3[1][1] </em> mat_3x3[0][2];<br>}</p>
<p>function quaternionToMatrix3x3(quat_4, mat_3x3) {<br>  const ww = quat_4[0] <em> quat_4[0];<br>  const wx = quat_4[0] </em> quat_4[1];<br>  const wy = quat_4[0] <em> quat_4[2];<br>  const wz = quat_4[0] </em> quat_4[3];</p>
<p>  const xx = quat_4[1] <em> quat_4[1];<br>  const yy = quat_4[2] </em> quat_4[2];<br>  const zz = quat_4[3] * quat_4[3];</p>
<p>  const xy = quat_4[1] <em> quat_4[2];<br>  const xz = quat_4[1] </em> quat_4[3];<br>  const yz = quat_4[2] * quat_4[3];</p>
<p>  const rr = xx + yy + zz;<br>  // normalization factor, just in case quaternion was not normalized<br>  let f = 1 / (ww + rr);<br>  const s = (ww - rr) <em> f;<br>  f </em>= 2;</p>
<p>  mat_3x3[0][0] = xx <em> f + s;<br>  mat_3x3[1][0] = (xy + wz) </em> f;<br>  mat_3x3[2][0] = (xz - wy) * f;</p>
<p>  mat_3x3[0][1] = (xy - wz) <em> f;<br>  mat_3x3[1][1] = yy </em> f + s;<br>  mat_3x3[2][1] = (yz + wx) * f;</p>
<p>  mat_3x3[0][2] = (xz + wy) <em> f;<br>  mat_3x3[1][2] = (yz - wx) </em> f;<br>  mat_3x3[2][2] = zz * f + s;<br>}</p>
<p>function jacobiN(a, n, w, v) {<br>  let i;<br>  let j;<br>  let k;<br>  let iq;<br>  let ip;<br>  let numPos;<br>  let tresh;<br>  let theta;<br>  let t;<br>  let tau;<br>  let sm;<br>  let s;<br>  let h;<br>  let g;<br>  let c;<br>  let tmp;<br>  const b = createArray(n);<br>  const z = createArray(n);</p>
<p>  const vtkROTATE = (aa, ii, jj, kk, ll) =&gt; {<br>    g = aa[ii][jj];<br>    h = aa[kk][ll];<br>    a[ii][jj] = g - s <em> (h + g </em> tau);<br>    a[kk][ll] = h + s <em> (g - h </em> tau);<br>  };</p>
<p>  // initialize<br>  for (ip = 0; ip &lt; n; ip++) {<br>    for (iq = 0; iq &lt; n; iq++) {<br>      v[ip][iq] = 0.0;<br>    }<br>    v[ip][ip] = 1.0;<br>  }<br>  for (ip = 0; ip &lt; n; ip++) {<br>    b[ip] = w[ip] = a[ip][ip];<br>    z[ip] = 0.0;<br>  }</p>
<p>  // begin rotation sequence<br>  for (i = 0; i &lt; VTK_MAX_ROTATIONS; i++) {<br>    sm = 0.0;<br>    for (ip = 0; ip &lt; n - 1; ip++) {<br>      for (iq = ip + 1; iq &lt; n; iq++) {<br>        sm += Math.abs(a[ip][iq]);<br>      }<br>    }<br>    if (sm === 0.0) {<br>      break;<br>    }</p>
<pre><code>// first 3 sweeps
if (i &lt; 3) {
  tresh = 0.2 * sm / (n * n);
} else {
  tresh = 0.0;
}

for (ip = 0; ip &lt; n - 1; ip++) {
  for (iq = ip + 1; iq &lt; n; iq++) {
    g = 100.0 * Math.abs(a[ip][iq]);

    // after 4 sweeps
    if (i &gt; 3 &amp;&amp; (Math.abs(w[ip]) + g) === Math.abs(w[ip]) &amp;&amp; (Math.abs(w[iq]) + g) === Math.abs(w[iq])) {
      a[ip][iq] = 0.0;
    } else if (Math.abs(a[ip][iq]) &gt; tresh) {
      h = w[iq] - w[ip];
      if ((Math.abs(h) + g) === Math.abs(h)) {
        t = (a[ip][iq]) / h;
      } else {
        theta = 0.5 * h / (a[ip][iq]);
        t = 1.0 / (Math.abs(theta) + Math.sqrt(1.0 + theta * theta));
        if (theta &lt; 0.0) {
          t = -t;
        }
      }
      c = 1.0 / Math.sqrt(1 + t * t);
      s = t * c;
      tau = s / (1.0 + c);
      h = t * a[ip][iq];
      z[ip] -= h;
      z[iq] += h;
      w[ip] -= h;
      w[iq] += h;
      a[ip][iq] = 0.0;

      // ip already shifted left by 1 unit
      for (j = 0; j &lt;= ip - 1; j++) {
        vtkROTATE(a, j, ip, j, iq);
      }
      // ip and iq already shifted left by 1 unit
      for (j = ip + 1; j &lt;= iq - 1; j++) {
        vtkROTATE(a, ip, j, j, iq);
      }
      // iq already shifted left by 1 unit
      for (j = iq + 1; j &lt; n; j++) {
        vtkROTATE(a, ip, j, iq, j);
      }
      for (j = 0; j &lt; n; j++) {
        vtkROTATE(v, j, ip, j, iq);
      }
    }
  }
}

for (ip = 0; ip &lt; n; ip++) {
  b[ip] += z[ip];
  w[ip] = b[ip];
  z[ip] = 0.0;
}
</code></pre><p>  }</p>
<p>  // this is NEVER called<br>  if (i &gt;= VTK_MAX_ROTATIONS) {<br>    vtkWarningMacro(‘vtkMath::Jacobi: Error extracting eigenfunctions’);<br>    return 0;<br>  }</p>
<p>  // sort eigenfunctions: these changes do not affect accuracy<br>  for (j = 0; j &lt; n - 1; j++) {<br>    // boundary incorrect<br>    k = j;<br>    tmp = w[k];<br>    for (i = j + 1; i &lt; n; i++) {<br>      // boundary incorrect, shifted already<br>      if (w[i] &gt;= tmp) {<br>        // why exchange if same?<br>        k = i;<br>        tmp = w[k];<br>      }<br>    }<br>    if (k !== j) {<br>      w[k] = w[j];<br>      w[j] = tmp;<br>      for (i = 0; i &lt; n; i++) {<br>        tmp = v[i][j];<br>        v[i][j] = v[i][k];<br>        v[i][k] = tmp;<br>      }<br>    }<br>  }<br>  // insure eigenvector consistency (i.e., Jacobi can compute vectors that<br>  // are negative of one another (.707,.707,0) and (-.707,-.707,0). This can<br>  // reek havoc in hyperstreamline/other stuff. We will select the most<br>  // positive eigenvector.<br>  const ceil_half_n = (n &gt;&gt; 1) + (n &amp; 1);<br>  for (j = 0; j &lt; n; j++) {<br>    for (numPos = 0, i = 0; i &lt; n; i++) {<br>      if (v[i][j] &gt;= 0.0) {<br>        numPos++;<br>      }<br>    }<br>    //    if ( numPos &lt; ceil(double(n)/double(2.0)) )<br>    if (numPos &lt; ceil_half_n) {<br>      for (i = 0; i &lt; n; i++) {<br>        v[i][j] *= -1.0;<br>      }<br>    }<br>  }<br>  return 1;<br>}</p>
<p>function matrix3x3ToQuaternion(mat_3x3, quat_4) {<br>  const tmp = [<br>    [0, 0, 0, 0],<br>    [0, 0, 0, 0],<br>    [0, 0, 0, 0],<br>    [0, 0, 0, 0],<br>  ];</p>
<p>  // on-diagonal elements<br>  tmp[0][0] = mat_3x3[0][0] + mat_3x3[1][1] + mat_3x3[2][2];<br>  tmp[1][1] = mat_3x3[0][0] - mat_3x3[1][1] - mat_3x3[2][2];<br>  tmp[2][2] = -mat_3x3[0][0] + mat_3x3[1][1] - mat_3x3[2][2];<br>  tmp[3][3] = -mat_3x3[0][0] - mat_3x3[1][1] + mat_3x3[2][2];</p>
<p>  // off-diagonal elements<br>  tmp[0][1] = tmp[1][0] = mat_3x3[2][1] - mat_3x3[1][2];<br>  tmp[0][2] = tmp[2][0] = mat_3x3[0][2] - mat_3x3[2][0];<br>  tmp[0][3] = tmp[3][0] = mat_3x3[1][0] - mat_3x3[0][1];</p>
<p>  tmp[1][2] = tmp[2][1] = mat_3x3[1][0] + mat_3x3[0][1];<br>  tmp[1][3] = tmp[3][1] = mat_3x3[0][2] + mat_3x3[2][0];<br>  tmp[2][3] = tmp[3][2] = mat_3x3[2][1] + mat_3x3[1][2];</p>
<p>  const eigenvectors = [<br>    [0, 0, 0, 0],<br>    [0, 0, 0, 0],<br>    [0, 0, 0, 0],<br>    [0, 0, 0, 0],<br>  ];<br>  const eigenvalues = [0, 0, 0, 0];</p>
<p>  // convert into format that JacobiN can use,<br>  // then use Jacobi to find eigenvalues and eigenvectors<br>  const NTemp = [0, 0, 0, 0];<br>  const eigenvectorsTemp = [0, 0, 0, 0];<br>  for (let i = 0; i &lt; 4; i++) {<br>    NTemp[i] = tmp[i];<br>    eigenvectorsTemp[i] = eigenvectors[i];<br>  }<br>  jacobiN(NTemp, 4, eigenvalues, eigenvectorsTemp);</p>
<p>  // the first eigenvector is the one we want<br>  quat_4[0] = eigenvectors[0][0];<br>  quat_4[1] = eigenvectors[1][0];<br>  quat_4[2] = eigenvectors[2][0];<br>  quat_4[3] = eigenvectors[3][0];<br>}</p>
<p>function multiplyQuaternion(quat_1, quat_2, quat_out) {<br>  const ww = quat_1[0] <em> quat_2[0];<br>  const wx = quat_1[0] </em> quat_2[1];<br>  const wy = quat_1[0] <em> quat_2[2];<br>  const wz = quat_1[0] </em> quat_2[3];</p>
<p>  const xw = quat_1[1] <em> quat_2[0];<br>  const xx = quat_1[1] </em> quat_2[1];<br>  const xy = quat_1[1] <em> quat_2[2];<br>  const xz = quat_1[1] </em> quat_2[3];</p>
<p>  const yw = quat_1[2] <em> quat_2[0];<br>  const yx = quat_1[2] </em> quat_2[1];<br>  const yy = quat_1[2] <em> quat_2[2];<br>  const yz = quat_1[2] </em> quat_2[3];</p>
<p>  const zw = quat_1[3] <em> quat_2[0];<br>  const zx = quat_1[3] </em> quat_2[1];<br>  const zy = quat_1[3] <em> quat_2[2];<br>  const zz = quat_1[3] </em> quat_2[3];</p>
<p>  quat_out[0] = ww - xx - yy - zz;<br>  quat_out[1] = wx + xw + yz - zy;<br>  quat_out[2] = wy - xz + yw + zx;<br>  quat_out[3] = wz + xy - yx + zw;<br>}</p>
<p>function orthogonalize3x3(a_3x3, out_3x3) {<br>  // copy the matrix<br>  for (let i = 0; i &lt; 3; i++) {<br>    out_3x3[0][i] = a_3x3[0][i];<br>    out_3x3[1][i] = a_3x3[1][i];<br>    out_3x3[2][i] = a_3x3[2][i];<br>  }</p>
<p>  // Pivot the matrix to improve accuracy<br>  const scale = createArray(3);<br>  const index = createArray(3);<br>  let largest;</p>
<p>  // Loop over rows to get implicit scaling information<br>  for (let i = 0; i &lt; 3; i++) {<br>    const x1 = Math.abs(out_3x3[i][0]);<br>    const x2 = Math.abs(out_3x3[i][1]);<br>    const x3 = Math.abs(out_3x3[i][2]);<br>    largest = (x2 &gt; x1 ? x2 : x1);<br>    largest = (x3 &gt; largest ? x3 : largest);<br>    scale[i] = 1;<br>    if (largest !== 0) {<br>      scale[i] /= largest;<br>    }<br>  }</p>
<p>  // first column<br>  const x1 = Math.abs(out_3x3[0][0]) <em> scale[0];<br>  const x2 = Math.abs(out_3x3[1][0]) </em> scale[1];<br>  const x3 = Math.abs(out_3x3[2][0]) * scale[2];<br>  index[0] = 0;<br>  largest = x1;<br>  if (x2 &gt;= largest) {<br>    largest = x2;<br>    index[0] = 1;<br>  }<br>  if (x3 &gt;= largest) {<br>    index[0] = 2;<br>  }<br>  if (index[0] !== 0) {<br>    vtkSwapVectors3(out_3x3[index[0]], out_3x3[0]);<br>    scale[index[0]] = scale[0];<br>  }</p>
<p>  // second column<br>  const y2 = Math.abs(out_3x3[1][1]) <em> scale[1];<br>  const y3 = Math.abs(out_3x3[2][1]) </em> scale[2];<br>  index[1] = 1;<br>  largest = y2;<br>  if (y3 &gt;= largest) {<br>    index[1] = 2;<br>    vtkSwapVectors3(out_3x3[2], out_3x3[1]);<br>  }</p>
<p>  // third column<br>  index[2] = 2;</p>
<p>  // A quaternion can only describe a pure rotation, not<br>  // a rotation with a flip, therefore the flip must be<br>  // removed before the matrix is converted to a quaternion.<br>  let flip = 0;<br>  if (determinant3x3(out_3x3) &lt; 0) {<br>    flip = 1;<br>    for (let i = 0; i &lt; 3; i++) {<br>      out_3x3[0][i] = -out_3x3[0][i];<br>      out_3x3[1][i] = -out_3x3[1][i];<br>      out_3x3[2][i] = -out_3x3[2][i];<br>    }<br>  }</p>
<p>  // Do orthogonalization using a quaternion intermediate<br>  // (this, essentially, does the orthogonalization via<br>  // diagonalization of an appropriately constructed symmetric<br>  // 4x4 matrix rather than by doing SVD of the 3x3 matrix)<br>  const quat = createArray(4);<br>  matrix3x3ToQuaternion(out_3x3, quat);<br>  quaternionToMatrix3x3(quat, out_3x3);</p>
<p>  // Put the flip back into the orthogonalized matrix.<br>  if (flip) {<br>    for (let i = 0; i &lt; 3; i++) {<br>      out_3x3[0][i] = -out_3x3[0][i];<br>      out_3x3[1][i] = -out_3x3[1][i];<br>      out_3x3[2][i] = -out_3x3[2][i];<br>    }<br>  }</p>
<p>  // Undo the pivoting<br>  if (index[1] !== 1) {<br>    vtkSwapVectors3(out_3x3[index[1]], out_3x3[1]);<br>  }<br>  if (index[0] !== 0) {<br>    vtkSwapVectors3(out_3x3[index[0]], out_3x3[0]);<br>  }<br>}</p>
<p>function diagonalize3x3(a_3x3, w_3, v_3x3) {<br>  let i;<br>  let j;<br>  let k;<br>  let maxI;<br>  let tmp;<br>  let maxVal;</p>
<p>  // do the matrix[3][3] to **matrix conversion for Jacobi<br>  const C = [<br>    createArray(3),<br>    createArray(3),<br>    createArray(3),<br>  ];<br>  const ATemp = createArray(3);<br>  const VTemp = createArray(3);<br>  for (i = 0; i &lt; 3; i++) {<br>    C[i][0] = a_3x3[i][0];<br>    C[i][1] = a_3x3[i][1];<br>    C[i][2] = a_3x3[i][2];<br>    ATemp[i] = C[i];<br>    VTemp[i] = v_3x3[i];<br>  }</p>
<p>  // diagonalize using Jacobi<br>  jacobiN(ATemp, 3, w_3, VTemp);</p>
<p>  // if all the eigenvalues are the same, return identity matrix<br>  if (w_3[0] === w_3[1] &amp;&amp; w_3[0] === w_3[2]) {<br>    identity3x3(v_3x3);<br>    return;<br>  }</p>
<p>  // transpose temporarily, it makes it easier to sort the eigenvectors<br>  transpose3x3(v_3x3, v_3x3);</p>
<p>  // if two eigenvalues are the same, re-orthogonalize to optimally line<br>  // up the eigenvectors with the x, y, and z axes<br>  for (i = 0; i &lt; 3; i++) {<br>    // two eigenvalues are the same<br>    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {<br>      // find maximum element of the independent eigenvector<br>      maxVal = Math.abs(v_3x3[i][0]);<br>      maxI = 0;<br>      for (j = 1; j &lt; 3; j++) {<br>        if (maxVal &lt; (tmp = Math.abs(v_3x3[i][j]))) {<br>          maxVal = tmp;<br>          maxI = j;<br>        }<br>      }<br>      // swap the eigenvector into its proper position<br>      if (maxI !== i) {<br>        tmp = w_3[maxI];<br>        w_3[maxI] = w_3[i];<br>        w_3[i] = tmp;<br>        vtkSwapVectors3(v_3x3[i], v_3x3[maxI]);<br>      }<br>      // maximum element of eigenvector should be positive<br>      if (v_3x3[maxI][maxI] &lt; 0) {<br>        v_3x3[maxI][0] = -v_3x3[maxI][0];<br>        v_3x3[maxI][1] = -v_3x3[maxI][1];<br>        v_3x3[maxI][2] = -v_3x3[maxI][2];<br>      }</p>
<pre><code>  // re-orthogonalize the other two eigenvectors
  j = (maxI + 1) % 3;
  k = (maxI + 2) % 3;

  v_3x3[j][0] = 0.0;
  v_3x3[j][1] = 0.0;
  v_3x3[j][2] = 0.0;
  v_3x3[j][j] = 1.0;
  cross(v_3x3[maxI], v_3x3[j], v_3x3[k]);
  normalize(v_3x3[k]);
  cross(v_3x3[k], v_3x3[maxI], v_3x3[j]);

  // transpose vectors back to columns
  transpose3x3(v_3x3, v_3x3);
  return;
}
</code></pre><p>  }</p>
<p>  // the three eigenvalues are different, just sort the eigenvectors<br>  // to align them with the x, y, and z axes</p>
<p>  // find the vector with the largest x element, make that vector<br>  // the first vector<br>  maxVal = Math.abs(v_3x3[0][0]);<br>  maxI = 0;<br>  for (i = 1; i &lt; 3; i++) {<br>    if (maxVal &lt; (tmp = Math.abs(v_3x3[i][0]))) {<br>      maxVal = tmp;<br>      maxI = i;<br>    }<br>  }<br>  // swap eigenvalue and eigenvector<br>  if (maxI !== 0) {<br>    tmp = w_3[maxI];<br>    w_3[maxI] = w_3[0];<br>    w_3[0] = tmp;<br>    vtkSwapVectors3(v_3x3[maxI], v_3x3[0]);<br>  }<br>  // do the same for the y element<br>  if (Math.abs(v_3x3[1][1]) &lt; Math.abs(v_3x3[2][1])) {<br>    tmp = w_3[2];<br>    w_3[2] = w_3[1];<br>    w_3[1] = tmp;<br>    vtkSwapVectors3(v_3x3[2], v_3x3[1]);<br>  }</p>
<p>  // ensure that the sign of the eigenvectors is correct<br>  for (i = 0; i &lt; 2; i++) {<br>    if (v_3x3[i][i] &lt; 0) {<br>      v_3x3[i][0] = -v_3x3[i][0];<br>      v_3x3[i][1] = -v_3x3[i][1];<br>      v_3x3[i][2] = -v_3x3[i][2];<br>    }<br>  }<br>  // set sign of final eigenvector to ensure that determinant is positive<br>  if (determinant3x3(v_3x3) &lt; 0) {<br>    v_3x3[2][0] = -v_3x3[2][0];<br>    v_3x3[2][1] = -v_3x3[2][1];<br>    v_3x3[2][2] = -v_3x3[2][2];<br>  }</p>
<p>  // transpose the eigenvectors back again<br>  transpose3x3(v_3x3, v_3x3);<br>}</p>
<p>function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {<br>  let i;<br>  const B = [createArray(3), createArray(3), createArray(3)];</p>
<p>  // copy so that A can be used for U or VT without risk<br>  for (i = 0; i &lt; 3; i++) {<br>    B[0][i] = a_3x3[0][i];<br>    B[1][i] = a_3x3[1][i];<br>    B[2][i] = a_3x3[2][i];<br>  }</p>
<p>  // temporarily flip if determinant is negative<br>  const d = determinant3x3(B);<br>  if (d &lt; 0) {<br>    for (i = 0; i &lt; 3; i++) {<br>      B[0][i] = -B[0][i];<br>      B[1][i] = -B[1][i];<br>      B[2][i] = -B[2][i];<br>    }<br>  }</p>
<p>  // orthogonalize, diagonalize, etc.<br>  orthogonalize3x3(B, u_3x3);<br>  transpose3x3(B, B);<br>  multiply3x3_mat3(B, u_3x3, vT_3x3);<br>  diagonalize3x3(vT_3x3, w_3, vT_3x3);<br>  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);<br>  transpose3x3(vT_3x3, vT_3x3);</p>
<p>  // re-create the flip<br>  if (d &lt; 0) {<br>    w_3[0] = -w_3[0];<br>    w_3[1] = -w_3[1];<br>    w_3[2] = -w_3[2];<br>  }<br>}</p>
<p>function luFactorLinearSystem(A, index, size) {<br>  let i;<br>  let j;<br>  let k;<br>  let largest;<br>  let maxI = 0;<br>  let sum;<br>  let temp1;<br>  let temp2;<br>  const scale = createArray(size);</p>
<p>  //<br>  // Loop over rows to get implicit scaling information<br>  //<br>  for (i = 0; i &lt; size; i++) {<br>    for (largest = 0.0, j = 0; j &lt; size; j++) {<br>      if ((temp2 = Math.abs(A[i][j])) &gt; largest) {<br>        largest = temp2;<br>      }<br>    }</p>
<pre><code>if (largest === 0.0) {
  vtkWarningMacro(&apos;Unable to factor linear system&apos;);
  return 0;
}
scale[i] = 1.0 / largest;
</code></pre><p>  }<br>  //<br>  // Loop over all columns using Crout’s method<br>  //<br>  for (j = 0; j &lt; size; j++) {<br>    for (i = 0; i &lt; j; i++) {<br>      sum = A[i][j];<br>      for (k = 0; k &lt; i; k++) {<br>        sum -= A[i][k] <em> A[k][j];<br>      }<br>      A[i][j] = sum;<br>    }<br>    //<br>    // Begin search for largest pivot element<br>    //<br>    for (largest = 0.0, i = j; i &lt; size; i++) {<br>      sum = A[i][j];<br>      for (k = 0; k &lt; j; k++) {<br>        sum -= A[i][k] </em> A[k][j];<br>      }<br>      A[i][j] = sum;</p>
<pre><code>  if ((temp1 = scale[i] * Math.abs(sum)) &gt;= largest) {
    largest = temp1;
    maxI = i;
  }
}
//
// Check for row interchange
//
if (j !== maxI) {
  for (k = 0; k &lt; size; k++) {
    temp1 = A[maxI][k];
    A[maxI][k] = A[j][k];
    A[j][k] = temp1;
  }
  scale[maxI] = scale[j];
}
//
// Divide by pivot element and perform elimination
//
index[j] = maxI;

if (Math.abs(A[j][j]) &lt;= VTK_SMALL_NUMBER) {
  vtkWarningMacro(&apos;Unable to factor linear system&apos;);
  return 0;
}

if (j !== (size - 1)) {
  temp1 = 1.0 / A[j][j];
  for (i = j + 1; i &lt; size; i++) {
    A[i][j] *= temp1;
  }
}
</code></pre><p>  }<br>  return 1;<br>}</p>
<p>function luSolveLinearSystem(A, index, x, size) {<br>  let i;<br>  let j;<br>  let ii;<br>  let idx;<br>  let sum;<br>  //<br>  // Proceed with forward and backsubstitution for L and U<br>  // matrices.  First, forward substitution.<br>  //<br>  for (ii = -1, i = 0; i &lt; size; i++) {<br>    idx = index[i];<br>    sum = x[idx];<br>    x[idx] = x[i];</p>
<pre><code>if (ii &gt;= 0) {
  for (j = ii; j &lt;= (i - 1); j++) {
    sum -= A[i][j] * x[j];
  }
} else if (sum !== 0.0) {
  ii = i;
}

x[i] = sum;
</code></pre><p>  }<br>  //<br>  // Now, back substitution<br>  //<br>  for (i = size - 1; i &gt;= 0; i–) {<br>    sum = x[i];<br>    for (j = i + 1; j &lt; size; j++) {<br>      sum -= A[i][j] * x[j];<br>    }<br>    x[i] = sum / A[i][i];<br>  }<br>}</p>
<p>function solveLinearSystem(A, x, size) {<br>  // if we solving something simple, just solve it<br>  if (size === 2) {<br>    const y = createArray(2);<br>    const det = determinant2x2(A[0][0], A[0][1], A[1][0], A[1][1]);</p>
<pre><code>if (det === 0.0) {
  // Unable to solve linear system
  return 0;
}

y[0] = (A[1][1] * x[0] - A[0][1] * x[1]) / det;
y[1] = (-A[1][0] * x[0] + A[0][0] * x[1]) / det;

x[0] = y[0];
x[1] = y[1];
return 1;
</code></pre><p>  } else if (size === 1) {<br>    if (A[0][0] === 0.0) {<br>      // Unable to solve linear system<br>      return 0;<br>    }</p>
<pre><code>x[0] /= A[0][0];
return 1;
</code></pre><p>  }</p>
<p>  //<br>  // System of equations is not trivial, use Crout’s method<br>  //</p>
<p>  // Check on allocation of working vectors<br>  const index = createArray(size);</p>
<p>  // Factor and solve matrix<br>  if (luFactorLinearSystem(A, index, size) === 0) {<br>    return 0;<br>  }<br>  luSolveLinearSystem(A, index, x, size);</p>
<p>  return 1;<br>}</p>
<p>function invertMatrix(A, AI, size, index = null, column = null) {<br>  const tmp1Size = index || createArray(size);<br>  const tmp2Size = column || createArray(size);</p>
<p>  // Factor matrix; then begin solving for inverse one column at a time.<br>  // Note: tmp1Size returned value is used later, tmp2Size is just working<br>  // memory whose values are not used in LUSolveLinearSystem<br>  if (luFactorLinearSystem(A, tmp1Size, size, tmp2Size) === 0) {<br>    return 0;<br>  }</p>
<p>  for (let j = 0; j &lt; size; j++) {<br>    for (let i = 0; i &lt; size; i++) {<br>      tmp2Size[i] = 0.0;<br>    }<br>    tmp2Size[j] = 1.0;</p>
<pre><code>luSolveLinearSystem(A, tmp1Size, tmp2Size, size);

for (let i = 0; i &lt; size; i++) {
  AI[i][j] = tmp2Size[i];
}
</code></pre><p>  }</p>
<p>  return 1;<br>}</p>
<p>function estimateMatrixCondition(A, size) {<br>  let minValue = +Number.MAX_VALUE;<br>  let maxValue = -Number.MAX_VALUE;</p>
<p>  // find the maximum value<br>  for (let i = 0; i &lt; size; i++) {<br>    for (let j = i; j &lt; size; j++) {<br>      if (Math.abs(A[i][j]) &gt; max) {<br>        maxValue = Math.abs(A[i][j]);<br>      }<br>    }<br>  }</p>
<p>  // find the minimum diagonal value<br>  for (let i = 0; i &lt; size; i++) {<br>    if (Math.abs(A[i][i]) &lt; min) {<br>      minValue = Math.abs(A[i][i]);<br>    }<br>  }</p>
<p>  if (minValue === 0.0) {<br>    return Number.MAX_VALUE;<br>  }<br>  return (maxValue / minValue);<br>}</p>
<p>function jacobi(a_3x3, w, v) {<br>  return jacobiN(a_3x3, 3, w, v);<br>}</p>
<p>function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {<br>  // check dimensional consistency<br>  if (numberOfSamples &lt; xOrder) {<br>    vtkWarningMacro(‘Insufficient number of samples. Underdetermined.’);<br>    return 0;<br>  }</p>
<p>  let i;<br>  let j;<br>  let k;</p>
<p>  // set up intermediate variables<br>  // Allocate matrix to hold X times transpose of X<br>  const XXt = createArray(xOrder); // size x by x<br>  // Allocate the array of eigenvalues and eigenvectors<br>  const eigenvals = createArray(xOrder);<br>  const eigenvecs = createArray(xOrder);</p>
<p>  // Clear the upper triangular region (and btw, allocate the eigenvecs as well)<br>  for (i = 0; i &lt; xOrder; i++) {<br>    eigenvecs[i] = createArray(xOrder);<br>    XXt[i] = createArray(xOrder);<br>    for (j = 0; j &lt; xOrder; j++) {<br>      XXt[i][j] = 0.0;<br>    }<br>  }</p>
<p>  // Calculate XXt upper half only, due to symmetry<br>  for (k = 0; k &lt; numberOfSamples; k++) {<br>    for (i = 0; i &lt; xOrder; i++) {<br>      for (j = i; j &lt; xOrder; j++) {<br>        XXt[i][j] += xt[k][i] * xt[k][j];<br>      }<br>    }<br>  }</p>
<p>  // now fill in the lower half of the XXt matrix<br>  for (i = 0; i &lt; xOrder; i++) {<br>    for (j = 0; j &lt; i; j++) {<br>      XXt[i][j] = XXt[j][i];<br>    }<br>  }</p>
<p>  // Compute the eigenvectors and eigenvalues<br>  jacobiN(XXt, xOrder, eigenvals, eigenvecs);</p>
<p>  // Smallest eigenval is at the end of the list (xOrder-1), and solution is<br>  // corresponding eigenvec.<br>  for (i = 0; i &lt; xOrder; i++) {<br>    mt[i][0] = eigenvecs[i][xOrder - 1];<br>  }</p>
<p>  return 1;<br>}</p>
<p>function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt, checkHomogeneous = true) {<br>  // check dimensional consistency<br>  if ((numberOfSamples &lt; xOrder) || (numberOfSamples &lt; yOrder)) {<br>    vtkWarningMacro(‘Insufficient number of samples. Underdetermined.’);<br>    return 0;<br>  }</p>
<p>  const homogenFlags = createArray(yOrder);<br>  let allHomogeneous = 1;<br>  let hmt;<br>  let homogRC = 0;<br>  let i;<br>  let j;<br>  let k;<br>  let someHomogeneous = 0;</p>
<p>  // Ok, first init some flags check and see if all the systems are homogeneous<br>  if (checkHomogeneous) {<br>    // If Y’ is zero, it’s a homogeneous system and can’t be solved via<br>    // the pseudoinverse method. Detect this case, warn the user, and<br>    // invoke SolveHomogeneousLeastSquares instead. Note that it doesn’t<br>    // really make much sense for yOrder to be greater than one in this case,<br>    // since that’s just yOrder occurrences of a 0 vector on the RHS, but<br>    // we allow it anyway. N</p>
<pre><code>// Initialize homogeneous flags on a per-right-hand-side basis
for (j = 0; j &lt; yOrder; j++) {
  homogenFlags[j] = 1;
}
for (i = 0; i &lt; numberOfSamples; i++) {
  for (j = 0; j &lt; yOrder; j++) {
    if (Math.abs(yt[i][j]) &gt; VTK_SMALL_NUMBER) {
      allHomogeneous = 0;
      homogenFlags[j] = 0;
    }
  }
}

// If we&apos;ve got one system, and it&apos;s homogeneous, do it and bail out quickly.
if (allHomogeneous &amp;&amp; yOrder === 1) {
  vtkWarningMacro(&apos;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&apos;);
  return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
}


// Ok, we&apos;ve got more than one system of equations.
// Figure out if we need to calculate the homogeneous equation solution for
// any of them.
if (allHomogeneous) {
  someHomogeneous = 1;
} else {
  for (j = 0; j &lt; yOrder; j++) {
    if (homogenFlags[j]) {
      someHomogeneous = 1;
    }
  }
}
</code></pre><p>  }</p>
<p>  // If necessary, solve the homogeneous problem<br>  if (someHomogeneous) {<br>    // hmt is the homogeneous equation version of mt, the general solution.<br>    hmt = createArray(xOrder);<br>    for (j = 0; j &lt; xOrder; j++) {<br>      // Only allocate 1 here, not yOrder, because here we’re going to solve<br>      // just the one homogeneous equation subset of the entire problem<br>      hmt[j] = [0];<br>    }</p>
<pre><code>// Ok, solve the homogeneous problem
homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
</code></pre><p>  }</p>
<p>  // set up intermediate variables<br>  const XXt = createArray(xOrder); // size x by x<br>  const XXtI = createArray(xOrder); // size x by x<br>  const XYt = createArray(xOrder); // size x by y<br>  for (i = 0; i &lt; xOrder; i++) {<br>    XXt[i] = createArray(xOrder);<br>    XXtI[i] = createArray(xOrder);</p>
<pre><code>for (j = 0; j &lt; xOrder; j++) {
  XXt[i][j] = 0.0;
  XXtI[i][j] = 0.0;
}

XYt[i] = createArray(yOrder);
for (j = 0; j &lt; yOrder; j++) {
  XYt[i][j] = 0.0;
}
</code></pre><p>  }</p>
<p>  // first find the pseudoinverse matrix<br>  for (k = 0; k &lt; numberOfSamples; k++) {<br>    for (i = 0; i &lt; xOrder; i++) {<br>      // first calculate the XXt matrix, only do the upper half (symmetrical)<br>      for (j = i; j &lt; xOrder; j++) {<br>        XXt[i][j] += xt[k][i] * xt[k][j];<br>      }</p>
<pre><code>  // now calculate the XYt matrix
  for (j = 0; j &lt; yOrder; j++) {
    XYt[i][j] += xt[k][i] * yt[k][j];
  }
}
</code></pre><p>  }</p>
<p>  // now fill in the lower half of the XXt matrix<br>  for (i = 0; i &lt; xOrder; i++) {<br>    for (j = 0; j &lt; i; j++) {<br>      XXt[i][j] = XXt[j][i];<br>    }<br>  }</p>
<p>  const successFlag = invertMatrix(XXt, XXtI, xOrder);</p>
<p>  // next get the inverse of XXt<br>  if (successFlag) {<br>    for (i = 0; i &lt; xOrder; i++) {<br>      for (j = 0; j &lt; yOrder; j++) {<br>        mt[i][j] = 0.0;<br>        for (k = 0; k &lt; xOrder; k++) {<br>          mt[i][j] += XXtI[i][k] * XYt[k][j];<br>        }<br>      }<br>    }<br>  }</p>
<p>  // Fix up any of the solutions that correspond to the homogeneous equation<br>  // problem.<br>  if (someHomogeneous) {<br>    for (j = 0; j &lt; yOrder; j++) {<br>      if (homogenFlags[j]) {<br>        // Fix this one<br>        for (i = 0; i &lt; xOrder; i++) {<br>          mt[i][j] = hmt[i][0];<br>        }<br>      }<br>    }<br>  }</p>
<p>  if (someHomogeneous) {<br>    return homogRC &amp;&amp; successFlag;<br>  }</p>
<p>  return successFlag;<br>}</p>
<p>function rgb2hsv(rgb, hsv) {<br>  let h;<br>  let s;<br>  const [r, g, b] = rgb;<br>  const onethird = 1.0 / 3.0;<br>  const onesixth = 1.0 / 6.0;<br>  const twothird = 2.0 / 3.0;</p>
<p>  let cmax = r;<br>  let cmin = r;</p>
<p>  if (g &gt; cmax) {<br>    cmax = g;<br>  } else if (g &lt; cmin) {<br>    cmin = g;<br>  }<br>  if (b &gt; cmax) {<br>    cmax = b;<br>  } else if (b &lt; cmin) {<br>    cmin = b;<br>  }<br>  const v = cmax;</p>
<p>  if (v &gt; 0.0) {<br>    s = (cmax - cmin) / cmax;<br>  } else {<br>    s = 0.0;<br>  }<br>  if (s &gt; 0) {<br>    if (r === cmax) {<br>      h = onesixth <em> (g - b) / (cmax - cmin);<br>    } else if (g === cmax) {<br>      h = onethird + onesixth </em> (b - r) / (cmax - cmin);<br>    } else {<br>      h = twothird + onesixth * (r - g) / (cmax - cmin);<br>    }<br>    if (h &lt; 0.0) {<br>      h += 1.0;<br>    }<br>  } else {<br>    h = 0.0;<br>  }</p>
<p>  // Set the values back to the array<br>  hsv[0] = h;<br>  hsv[1] = s;<br>  hsv[2] = v;<br>}</p>
<p>function hsv2rgb(hsv, rgb) {<br>  const [h, s, v] = hsv;<br>  const onethird = 1.0 / 3.0;<br>  const onesixth = 1.0 / 6.0;<br>  const twothird = 2.0 / 3.0;<br>  const fivesixth = 5.0 / 6.0;<br>  let r;<br>  let g;<br>  let b;</p>
<p>  // compute RGB from HSV<br>  if (h &gt; onesixth &amp;&amp; h &lt;= onethird) {<br>    // green/red<br>    g = 1.0;<br>    r = (onethird - h) / onesixth;<br>    b = 0.0;<br>  } else if (h &gt; onethird &amp;&amp; h &lt;= 0.5) {<br>    // green/blue<br>    g = 1.0;<br>    b = (h - onethird) / onesixth;<br>    r = 0.0;<br>  } else if (h &gt; 0.5 &amp;&amp; h &lt;= twothird) {<br>    // blue/green<br>    b = 1.0;<br>    g = (twothird - h) / onesixth;<br>    r = 0.0;<br>  } else if (h &gt; twothird &amp;&amp; h &lt;= fivesixth) { // blue/red<br>    b = 1.0;<br>    r = (h - twothird) / onesixth;<br>    g = 0.0;<br>  } else if (h &gt; fivesixth &amp;&amp; h &lt;= 1.0) { // red/blue<br>    r = 1.0;<br>    b = (1.0 - h) / onesixth;<br>    g = 0.0;<br>  } else { // red/green<br>    r = 1.0;<br>    g = h / onesixth;<br>    b = 0.0;<br>  }</p>
<p>  // add Saturation to the equation.<br>  r = (s <em> r + (1.0 - s));<br>  g = (s </em> g + (1.0 - s));<br>  b = (s * b + (1.0 - s));</p>
<p>  r <em>= v;<br>  g </em>= v;<br>  b *= v;</p>
<p>  // Assign back to the array<br>  rgb[0] = r;<br>  rgb[1] = g;<br>  rgb[2] = b;<br>}</p>
<p>function lab2xyz(lab, xyz) {<br>  // LAB to XYZ<br>  const [L, a, b] = lab;<br>  let var_Y = (L + 16) / 116;<br>  let var_X = a / 500 + var_Y;<br>  let var_Z = var_Y - b / 200;</p>
<p>  if (Math.pow(var_Y, 3) &gt; 0.008856) {<br>    var_Y = Math.pow(var_Y, 3);<br>  } else {<br>    var_Y = (var_Y - 16.0 / 116.0) / 7.787;<br>  }</p>
<p>  if (Math.pow(var_X, 3) &gt; 0.008856) {<br>    var_X = Math.pow(var_X, 3);<br>  } else {<br>    var_X = (var_X - 16.0 / 116.0) / 7.787;<br>  }</p>
<p>  if (Math.pow(var_Z, 3) &gt; 0.008856) {<br>    var_Z = Math.pow(var_Z, 3);<br>  } else {<br>    var_Z = (var_Z - 16.0 / 116.0) / 7.787;<br>  }<br>  const ref_X = 0.9505;<br>  const ref_Y = 1.000;<br>  const ref_Z = 1.089;<br>  xyz[0] = ref_X <em> var_X; // ref_X = 0.9505  Observer= 2 deg Illuminant= D65<br>  xyz[1] = ref_Y </em> var_Y; // ref_Y = 1.000<br>  xyz[2] = ref_Z * var_Z; // ref_Z = 1.089<br>}</p>
<p>function xyz2lab(xyz, lab) {<br>  const [x, y, z] = xyz;<br>  const ref_X = 0.9505;<br>  const ref_Y = 1.000;<br>  const ref_Z = 1.089;<br>  let var_X = x / ref_X;  // ref_X = 0.9505  Observer= 2 deg, Illuminant= D65<br>  let var_Y = y / ref_Y;  // ref_Y = 1.000<br>  let var_Z = z / ref_Z;  // ref_Z = 1.089</p>
<p>  if (var_X &gt; 0.008856) var_X = Math.pow(var_X, 1.0 / 3.0);<br>  else var_X = (7.787 <em> var_X) + (16.0 / 116.0);<br>  if (var_Y &gt; 0.008856) var_Y = Math.pow(var_Y, 1.0 / 3.0);<br>  else var_Y = (7.787 </em> var_Y) + (16.0 / 116.0);<br>  if (var_Z &gt; 0.008856) var_Z = Math.pow(var_Z, 1.0 / 3.0);<br>  else var_Z = (7.787 * var_Z) + (16.0 / 116.0);</p>
<p>  lab[0] = (116 <em> var_Y) - 16;<br>  lab[1] = 500 </em> (var_X - var_Y);<br>  lab[2] = 200 * (var_Y - var_Z);<br>}</p>
<p>function xyz2rgb(xyz, rgb) {<br>  const [x, y, z] = xyz;<br>  let r = x <em> 3.2406 + y </em> -1.5372 + z <em> -0.4986;<br>  let g = x </em> -0.9689 + y <em> 1.8758 + z </em> 0.0415;<br>  let b = x <em> 0.0557 + y </em> -0.2040 + z * 1.0570;</p>
<p>  // The following performs a “gamma correction” specified by the sRGB color<br>  // space.  sRGB is defined by a canonical definition of a display monitor and<br>  // has been standardized by the International Electrotechnical Commission (IEC<br>  // 61966-2-1).  The nonlinearity of the correction is designed to make the<br>  // colors more perceptually uniform.  This color space has been adopted by<br>  // several applications including Adobe Photoshop and Microsoft Windows color<br>  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable<br>  // to assume it is close to this one.<br>  if (r &gt; 0.0031308) r = 1.055 <em> (Math.pow(r, (1 / 2.4))) - 0.055;<br>  else r = 12.92 </em> r;<br>  if (g &gt; 0.0031308) g = 1.055 <em> (Math.pow(g, (1 / 2.4))) - 0.055;<br>  else g = 12.92 </em> g;<br>  if (b &gt; 0.0031308) b = 1.055 <em> (Math.pow(b, (1 / 2.4))) - 0.055;<br>  else b = 12.92 </em> b;</p>
<p>  // Clip colors. ideally we would do something that is perceptually closest<br>  // (since we can see colors outside of the display gamut), but this seems to<br>  // work well enough.<br>  let maxVal = r;<br>  if (maxVal &lt; g) maxVal = g;<br>  if (maxVal &lt; b) maxVal = b;<br>  if (maxVal &gt; 1.0) {<br>    r /= maxVal;<br>    g /= maxVal;<br>    b /= maxVal;<br>  }<br>  if (r &lt; 0) r = 0;<br>  if (g &lt; 0) g = 0;<br>  if (b &lt; 0) b = 0;</p>
<p>  // Push values back to array<br>  rgb[0] = r;<br>  rgb[1] = g;<br>  rgb[2] = b;<br>}</p>
<p>function rgb2xyz(rgb, xyz) {<br>  let [r, g, b] = rgb;<br>  // The following performs a “gamma correction” specified by the sRGB color<br>  // space.  sRGB is defined by a canonical definition of a display monitor and<br>  // has been standardized by the International Electrotechnical Commission (IEC<br>  // 61966-2-1).  The nonlinearity of the correction is designed to make the<br>  // colors more perceptually uniform.  This color space has been adopted by<br>  // several applications including Adobe Photoshop and Microsoft Windows color<br>  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable<br>  // to assume it is close to this one.<br>  if (r &gt; 0.04045) r = Math.pow((r + 0.055) / 1.055, 2.4);<br>  else r = r / 12.92;<br>  if (g &gt; 0.04045) g = Math.pow((g + 0.055) / 1.055, 2.4);<br>  else g = g / 12.92;<br>  if (b &gt; 0.04045) b = Math.pow((b + 0.055) / 1.055, 2.4);<br>  else b = b / 12.92;</p>
<p>  // Observer. = 2 deg, Illuminant = D65<br>  xyz[0] = r <em> 0.4124 + g </em> 0.3576 + b <em> 0.1805;<br>  xyz[1] = r </em> 0.2126 + g <em> 0.7152 + b </em> 0.0722;<br>  xyz[2] = r <em> 0.0193 + g </em> 0.1192 + b * 0.9505;<br>}</p>
<p>function rgb2lab(rgb, lab) {<br>  const xyz = [0, 0, 0];<br>  rgb2xyz(rgb, xyz);<br>  xyz2lab(xyz, lab);<br>}</p>
<p>function LabToRGB(lab, rgb) {<br>  const xyz = [0, 0, 0];<br>  lab2xyz(lab, xyz);<br>  xyz2rgb(xyz, rgb);<br>}</p>
<p>function uninitializeBounds(bounds) {<br>  bounds[0] = 1.0;<br>  bounds[1] = -1.0;<br>  bounds[2] = 1.0;<br>  bounds[3] = -1.0;<br>  bounds[4] = 1.0;<br>  bounds[5] = -1.0;<br>}</p>
<p>function areBoundsInitialized(bounds) {<br>  return !(bounds[1] - bounds[0] &lt; 0.0);<br>}</p>
<p>function clampValue(value, minValue, maxValue) {<br>  if (value &lt; minValue) {<br>    return minValue;<br>  }<br>  if (value &gt; maxValue) {<br>    return maxValue;<br>  }<br>  return value;<br>}</p>
<p>function clampAndNormalizeValue(value, range) {<br>  let result = 0;<br>  if (range[0] !== range[1]) {<br>    // clamp<br>    if (value &lt; range[0]) {<br>      result = range[0];<br>    } else {<br>      if (value &gt; range[1]) {<br>        result = range[1];<br>      } else {<br>        result = value;<br>      }<br>    }<br>    // normalize<br>    result = (result - range[0]) / (range[1] - range[0]);<br>  }</p>
<p>  return result;<br>}</p>
<p>const getScalarTypeFittingRange = notImplemented(‘GetScalarTypeFittingRange’);<br>const getAdjustedScalarRange = notImplemented(‘GetAdjustedScalarRange’);</p>
<p>function extentIsWithinOtherExtent(extent1, extent2) {<br>  if (!extent1 || !extent2) {<br>    return 0;<br>  }</p>
<p>  for (let i = 0; i &lt; 6; i += 2) {<br>    if (extent1[i] &lt; extent2[i] || extent1[i] &gt; extent2[i + 1] ||<br>      extent1[i + 1] &lt; extent2[i] || extent1[i + 1] &gt; extent2[i + 1]) {<br>      return 0;<br>    }<br>  }</p>
<p>  return 1;<br>}</p>
<p>function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {<br>  if (!bounds1_6 || !bounds2_6) {<br>    return 0;<br>  }<br>  for (let i = 0; i &lt; 6; i += 2) {<br>    if (bounds1_6[i] + delta_3[i / 2] &lt; bounds2_6[i]<br>      || bounds1_6[i] - delta_3[i / 2] &gt; bounds2_6[i + 1]<br>      || bounds1_6[i + 1] + delta_3[i / 2] &lt; bounds2_6[i]<br>      || bounds1_6[i + 1] - delta_3[i / 2] &gt; bounds2_6[i + 1]) {<br>      return 0;<br>    }<br>  }<br>  return 1;<br>}</p>
<p>function pointIsWithinBounds(point_3, bounds_6, delta_3) {<br>  if (!point_3 || !bounds_6 || !delta_3) {<br>    return 0;<br>  }<br>  for (let i = 0; i &lt; 3; i++) {<br>    if (point_3[i] + delta_3[i] &lt; bounds_6[2 <em> i] || point_3[i] - delta_3[i] &gt; bounds_6[2 </em> i + 1]) {<br>      return 0;<br>    }<br>  }<br>  return 1;<br>}</p>
<p>function solve3PointCircle(p1, p2, p3, center) {<br>  const v21 = createArray(3);<br>  const v32 = createArray(3);<br>  const v13 = createArray(3);<br>  const v12 = createArray(3);<br>  const v23 = createArray(3);<br>  const v31 = createArray(3);</p>
<p>  for (let i = 0; i &lt; 3; ++i) {<br>    v21[i] = p1[i] - p2[i];<br>    v32[i] = p2[i] - p3[i];<br>    v13[i] = p3[i] - p1[i];<br>    v12[i] = -v21[i];<br>    v23[i] = -v32[i];<br>    v31[i] = -v13[i];<br>  }</p>
<p>  const norm12 = norm(v12);<br>  const norm23 = norm(v23);<br>  const norm13 = norm(v13);</p>
<p>  const crossv21v32 = createArray(3);<br>  cross(v21, v32, crossv21v32);<br>  const normCross = norm(crossv21v32);</p>
<p>  const radius = (norm12 <em> norm23 </em> norm13) / (2 * normCross);</p>
<p>  const normCross22 = 2 <em> normCross </em> normCross;<br>  const alpha = ((norm23 <em> norm23) </em> dot(v21, v31)) / normCross22;<br>  const beta = ((norm13 <em> norm13) </em> dot(v12, v32)) / normCross22;<br>  const gamma = ((norm12 <em> norm12) </em> dot(v13, v23)) / normCross22;</p>
<p>  for (let i = 0; i &lt; 3; ++i) {<br>    center[i] = alpha <em> p1[i] + beta </em> p2[i] + gamma * p3[i];<br>  }<br>  return radius;<br>}</p>
<p>const inf = Infinity;<br>const negInf = -Infinity;</p>
<p>const isInf = value =&gt; !Number.isFinite(value);<br>const isNan = Number.isNaN;<br>const isFinite = Number.isFinite;</p>
<p>// JavaScript - add-on ———————-</p>
<p>function createUninitializedBouds() {<br>  return [].concat([<br>    Number.MAX_VALUE, Number.MIN_VALUE, // X<br>    Number.MAX_VALUE, Number.MIN_VALUE, // Y<br>    Number.MAX_VALUE, Number.MIN_VALUE, // Z<br>  ]);<br>}</p>
<p>// —————————————————————————-<br>// Only Static API<br>// —————————————————————————-</p>
<p>export default {<br>  Pi,<br>  radiansFromDegrees,<br>  degreesFromRadians,<br>  round,<br>  floor,<br>  ceil,<br>  ceilLog2,<br>  min,<br>  max,<br>  isPowerOfTwo,<br>  nearestPowerOfTwo,<br>  factorial,<br>  binomial,<br>  beginCombination,<br>  nextCombination,<br>  randomSeed,<br>  getSeed,<br>  random,<br>  gaussian,<br>  add,<br>  subtract,<br>  multiplyScalar,<br>  multiplyScalar2D,<br>  dot,<br>  outer,<br>  cross,<br>  norm,<br>  normalize,<br>  perpendiculars,<br>  projectVector,<br>  projectVector2D,<br>  distance2BetweenPoints,<br>  angleBetweenVectors,<br>  gaussianAmplitude,<br>  gaussianWeight,<br>  dot2D,<br>  outer2D,<br>  norm2D,<br>  normalize2D,<br>  determinant2x2,<br>  LUFactor3x3,<br>  LUSolve3x3,<br>  linearSolve3x3,<br>  multiply3x3_vect3,<br>  multiply3x3_mat3,<br>  multiplyMatrix,<br>  transpose3x3,<br>  invert3x3,<br>  identity3x3,<br>  determinant3x3,<br>  quaternionToMatrix3x3,<br>  matrix3x3ToQuaternion,<br>  multiplyQuaternion,<br>  orthogonalize3x3,<br>  diagonalize3x3,<br>  singularValueDecomposition3x3,<br>  solveLinearSystem,<br>  invertMatrix,<br>  luFactorLinearSystem,<br>  luSolveLinearSystem,<br>  estimateMatrixCondition,<br>  jacobi,<br>  jacobiN,<br>  solveHomogeneousLeastSquares,<br>  solveLeastSquares,<br>  rgb2hsv,<br>  hsv2rgb,<br>  lab2xyz,<br>  xyz2lab,<br>  xyz2rgb,<br>  rgb2xyz,<br>  rgb2lab,<br>  LabToRGB,<br>  uninitializeBounds,<br>  areBoundsInitialized,<br>  clampValue,<br>  clampAndNormalizeValue,<br>  getScalarTypeFittingRange,<br>  getAdjustedScalarRange,<br>  extentIsWithinOtherExtent,<br>  boundsIsWithinOtherBounds,<br>  pointIsWithinBounds,<br>  solve3PointCircle,<br>  inf,<br>  negInf,<br>  isInf,<br>  isNan,<br>  isFinite,</p>
<p>  // JS add-on<br>  createUninitializedBouds,<br>};</p>
<h1 id="Source" class="article-heading"><a href="#Source" class="headerlink" title="Source"></a>Source<a class="article-anchor" href="#Source" aria-hidden="true"></a></h1><figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* eslint-disable camelcase                                                  */</span></span><br><span class="line"><span class="comment">/* eslint-disable no-cond-assign                                             */</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">const</span> VTK_MAX_ROTATIONS = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> VTK_SMALL_NUMBER = <span class="number">1.0e-12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notImplemented</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> () =&gt; <span class="built_in">console</span>.log(<span class="string">'vtkMath::$&#123;method&#125; - NOT IMPLEMENTED'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vtkSwapVectors3</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = v1[i];</span><br><span class="line">    v1[i] = v2[i];</span><br><span class="line">    v2[i] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">size = 3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array = [];</span><br><span class="line">  <span class="keyword">while</span> (array.length &lt; size) &#123;</span><br><span class="line">    array.push(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Global methods</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = () =&gt; <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="keyword">const</span> radiansFromDegrees = deg =&gt; deg / <span class="number">180</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="keyword">const</span> degreesFromRadians = rad =&gt; rad * <span class="number">180</span> / <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="keyword">const</span> round = <span class="built_in">Math</span>.round;</span><br><span class="line"><span class="keyword">const</span> floor = <span class="built_in">Math</span>.floor;</span><br><span class="line"><span class="keyword">const</span> ceil = <span class="built_in">Math</span>.ceil;</span><br><span class="line"><span class="keyword">const</span> ceilLog2 = notImplemented(<span class="string">'ceilLog2'</span>);</span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min;</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max;</span><br><span class="line"><span class="keyword">const</span> isPowerOfTwo = notImplemented(<span class="string">'isPowerOfTwo'</span>);</span><br><span class="line"><span class="keyword">const</span> nearestPowerOfTwo = notImplemented(<span class="string">'nearestPowerOfTwo'</span>);</span><br><span class="line"><span class="keyword">const</span> factorial = notImplemented(<span class="string">'factorial'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binomial</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    r *= (m - i + <span class="number">1</span>) / i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginCombination</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> r = createArray(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    r[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextCombination</span>(<span class="params">m, n, r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> status = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r[i] &lt; m - n + i) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = r[i] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        r[i++] = j++;</span><br><span class="line">      &#125;</span><br><span class="line">      status = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomSeed = notImplemented(<span class="string">'randomSeed'</span>);</span><br><span class="line"><span class="keyword">const</span> getSeed = notImplemented(<span class="string">'getSeed'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">minValue = 0, maxValue = 1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> delta = maxValue - minValue;</span><br><span class="line">  <span class="keyword">return</span> minValue + (delta * <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gaussian = notImplemented(<span class="string">'gaussian'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vect3 operations</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, out</span>) </span>&#123;</span><br><span class="line">  out[<span class="number">0</span>] = a[<span class="number">0</span>] + b[<span class="number">0</span>];</span><br><span class="line">  out[<span class="number">1</span>] = a[<span class="number">1</span>] + b[<span class="number">1</span>];</span><br><span class="line">  out[<span class="number">2</span>] = a[<span class="number">2</span>] + b[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b, out</span>) </span>&#123;</span><br><span class="line">  out[<span class="number">0</span>] = a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">  out[<span class="number">1</span>] = a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">  out[<span class="number">2</span>] = a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyScalar</span>(<span class="params">vec, scalar</span>) </span>&#123;</span><br><span class="line">  vec[<span class="number">0</span>] *= scalar;</span><br><span class="line">  vec[<span class="number">1</span>] *= scalar;</span><br><span class="line">  vec[<span class="number">2</span>] *= scalar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyScalar2D</span>(<span class="params">vec, scalar</span>) </span>&#123;</span><br><span class="line">  vec[<span class="number">0</span>] *= scalar;</span><br><span class="line">  vec[<span class="number">1</span>] *= scalar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dot</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x[<span class="number">0</span>] * y[<span class="number">0</span>] + x[<span class="number">1</span>] * y[<span class="number">1</span>] + x[<span class="number">2</span>] * y[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">x, y, out_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      out_3x3[i][j] = x[i] * y[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cross</span>(<span class="params">x, y, out</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Zx = x[<span class="number">1</span>] * y[<span class="number">2</span>] - x[<span class="number">2</span>] * y[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> Zy = x[<span class="number">2</span>] * y[<span class="number">0</span>] - x[<span class="number">0</span>] * y[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> Zz = x[<span class="number">0</span>] * y[<span class="number">1</span>] - x[<span class="number">1</span>] * y[<span class="number">0</span>];</span><br><span class="line">  out[<span class="number">0</span>] = Zx;</span><br><span class="line">  out[<span class="number">1</span>] = Zy;</span><br><span class="line">  out[<span class="number">2</span>] = Zz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">norm</span>(<span class="params">x, n = 3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.abs(x);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x[<span class="number">0</span>] * x[<span class="number">0</span>] + x[<span class="number">1</span>] * x[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x[<span class="number">0</span>] * x[<span class="number">0</span>] + x[<span class="number">1</span>] * x[<span class="number">1</span>] + x[<span class="number">2</span>] * x[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          sum += x[i] * x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(sum);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> den = norm(x);</span><br><span class="line">  <span class="keyword">if</span> (den !== <span class="number">0.0</span>) &#123;</span><br><span class="line">    x[<span class="number">0</span>] /= den;</span><br><span class="line">    x[<span class="number">1</span>] /= den;</span><br><span class="line">    x[<span class="number">2</span>] /= den;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perpendiculars</span>(<span class="params">x, y, z, theta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x2 = x[<span class="number">0</span>] * x[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> y2 = x[<span class="number">1</span>] * x[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> z2 = x[<span class="number">2</span>] * x[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> r = <span class="built_in">Math</span>.sqrt(x2 + y2 + z2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dx;</span><br><span class="line">  <span class="keyword">let</span> dy;</span><br><span class="line">  <span class="keyword">let</span> dz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transpose the vector to avoid divide-by-zero error</span></span><br><span class="line">  <span class="keyword">if</span> (x2 &gt; y2 &amp;&amp; x2 &gt; z2) &#123;</span><br><span class="line">    dx = <span class="number">0</span>;</span><br><span class="line">    dy = <span class="number">1</span>;</span><br><span class="line">    dz = <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y2 &gt; z2) &#123;</span><br><span class="line">    dx = <span class="number">1</span>;</span><br><span class="line">    dy = <span class="number">2</span>;</span><br><span class="line">    dz = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dx = <span class="number">2</span>;</span><br><span class="line">    dy = <span class="number">0</span>;</span><br><span class="line">    dz = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> a = x[dx] / r;</span><br><span class="line">  <span class="keyword">const</span> b = x[dy] / r;</span><br><span class="line">  <span class="keyword">const</span> c = x[dz] / r;</span><br><span class="line">  <span class="keyword">const</span> tmp = <span class="built_in">Math</span>.sqrt(a * a + c * c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (theta !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sintheta = <span class="built_in">Math</span>.sin(theta);</span><br><span class="line">    <span class="keyword">const</span> costheta = <span class="built_in">Math</span>.cos(theta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y) &#123;</span><br><span class="line">      y[dx] = (c * costheta - a * b * sintheta) / tmp;</span><br><span class="line">      y[dy] = sintheta * tmp;</span><br><span class="line">      y[dz] = (-a * costheta - b * c * sintheta) / tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z) &#123;</span><br><span class="line">      z[dx] = (-c * sintheta - a * b * costheta) / tmp;</span><br><span class="line">      z[dy] = costheta * tmp;</span><br><span class="line">      z[dz] = (a * sintheta - b * c * costheta) / tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y) &#123;</span><br><span class="line">      y[dx] = c / tmp;</span><br><span class="line">      y[dy] = <span class="number">0</span>;</span><br><span class="line">      y[dz] = -a / tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z) &#123;</span><br><span class="line">      z[dx] = -a * b / tmp;</span><br><span class="line">      z[dy] = tmp;</span><br><span class="line">      z[dz] = -b * c / tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">projectVector</span>(<span class="params">a, b, projection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bSquared = dot(b, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bSquared === <span class="number">0</span>) &#123;</span><br><span class="line">    projection[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    projection[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    projection[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scale = dot(a, b) / bSquared;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    projection[i] = b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  multiplyScalar(projection, scale);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dot2D</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x[<span class="number">0</span>] * y[<span class="number">0</span>] + x[<span class="number">1</span>] * y[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">projectVector2D</span>(<span class="params">a, b, projection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bSquared = dot2D(b, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bSquared === <span class="number">0</span>) &#123;</span><br><span class="line">    projection[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    projection[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scale = dot2D(a, b) / bSquared;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    projection[i] = b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  multiplyScalar2D(projection, scale);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance2BetweenPoints</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x[<span class="number">0</span>] - y[<span class="number">0</span>]) * (x[<span class="number">0</span>] - y[<span class="number">0</span>]) + (x[<span class="number">1</span>] - y[<span class="number">1</span>]) * (x[<span class="number">1</span>] - y[<span class="number">1</span>]) + (x[<span class="number">2</span>] - y[<span class="number">2</span>]) * (x[<span class="number">2</span>] - y[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">angleBetweenVectors</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> crossVect = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">  cross(v1, v2, crossVect);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(norm(cross), dot(v1, v2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gaussianAmplitude</span>(<span class="params">mean, variance, position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> distanceFromMean = <span class="built_in">Math</span>.abs(mean - position);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> / (<span class="built_in">Math</span>.sqrt(<span class="number">2</span> * <span class="built_in">Math</span>.PI * variance)) * <span class="built_in">Math</span>.exp(-(<span class="built_in">Math</span>.pow(distanceFromMean, <span class="number">2</span>)) / (<span class="number">2</span> * variance));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gaussianWeight</span>(<span class="params">mean, variance, position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> distanceFromMean = <span class="built_in">Math</span>.abs(mean - position);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(-(<span class="built_in">Math</span>.pow(distanceFromMean, <span class="number">2</span>)) / (<span class="number">2</span> * variance));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer2D</span>(<span class="params">x, y, out_2x2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">      out_2x2[i][j] = x[i] * y[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">norm2D</span>(<span class="params">x2D</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x2D[<span class="number">0</span>] * x2D[<span class="number">0</span>] + x2D[<span class="number">1</span>] * x2D[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize2D</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> den = norm2D(x);</span><br><span class="line">  <span class="keyword">if</span> (den !== <span class="number">0.0</span>) &#123;</span><br><span class="line">    x[<span class="number">0</span>] /= den;</span><br><span class="line">    x[<span class="number">1</span>] /= den;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determinant2x2</span>(<span class="params">c1, c2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (c1[<span class="number">0</span>] * c2[<span class="number">1</span>] - c2[<span class="number">0</span>] * c1[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LUFactor3x3</span>(<span class="params">mat_3x3, index_3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxI;</span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">  <span class="keyword">let</span> largest;</span><br><span class="line">  <span class="keyword">const</span> scale = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop over rows to get implicit scaling information</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    largest = <span class="built_in">Math</span>.abs(mat_3x3[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((tmp = <span class="built_in">Math</span>.abs(mat_3x3[i][<span class="number">1</span>])) &gt; largest) &#123;</span><br><span class="line">      largest = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((tmp = <span class="built_in">Math</span>.abs(mat_3x3[i][<span class="number">2</span>])) &gt; largest) &#123;</span><br><span class="line">      largest = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    scale[i] = <span class="number">1</span> / largest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop over all columns using Crout's method</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// first column</span></span><br><span class="line">  largest = scale[<span class="number">0</span>] * <span class="built_in">Math</span>.abs(mat_3x3[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  maxI = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((tmp = scale[<span class="number">1</span>] * <span class="built_in">Math</span>.abs(mat_3x3[<span class="number">1</span>][<span class="number">0</span>])) &gt;= largest) &#123;</span><br><span class="line">    largest = tmp;</span><br><span class="line">    maxI = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((tmp = scale[<span class="number">2</span>] * <span class="built_in">Math</span>.abs(mat_3x3[<span class="number">2</span>][<span class="number">0</span>])) &gt;= largest) &#123;</span><br><span class="line">    maxI = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (maxI !== <span class="number">0</span>) &#123;</span><br><span class="line">    vtkSwapVectors3(mat_3x3[maxI], mat_3x3[<span class="number">0</span>]);</span><br><span class="line">    scale[maxI] = scale[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  index_3[<span class="number">0</span>] = maxI;</span><br><span class="line"></span><br><span class="line">  mat_3x3[<span class="number">1</span>][<span class="number">0</span>] /= mat_3x3[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">0</span>] /= mat_3x3[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// second column</span></span><br><span class="line">  mat_3x3[<span class="number">1</span>][<span class="number">1</span>] -= mat_3x3[<span class="number">1</span>][<span class="number">0</span>] * mat_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">1</span>] -= mat_3x3[<span class="number">2</span>][<span class="number">0</span>] * mat_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  largest = scale[<span class="number">1</span>] * <span class="built_in">Math</span>.abs(mat_3x3[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  maxI = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((tmp = scale[<span class="number">2</span>] * <span class="built_in">Math</span>.abs(mat_3x3[<span class="number">2</span>][<span class="number">1</span>])) &gt;= largest) &#123;</span><br><span class="line">    maxI = <span class="number">2</span>;</span><br><span class="line">    vtkSwapVectors3(mat_3x3[<span class="number">2</span>], mat_3x3[<span class="number">1</span>]);</span><br><span class="line">    scale[<span class="number">2</span>] = scale[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  index_3[<span class="number">1</span>] = maxI;</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">1</span>] /= mat_3x3[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// third column</span></span><br><span class="line">  mat_3x3[<span class="number">1</span>][<span class="number">2</span>] -= mat_3x3[<span class="number">1</span>][<span class="number">0</span>] * mat_3x3[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">2</span>] -= mat_3x3[<span class="number">2</span>][<span class="number">0</span>] * mat_3x3[<span class="number">0</span>][<span class="number">2</span>] + mat_3x3[<span class="number">2</span>][<span class="number">1</span>] * mat_3x3[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">  index_3[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LUSolve3x3</span>(<span class="params">mat_3x3, index_3, x_3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// forward substitution</span></span><br><span class="line">  <span class="keyword">let</span> sum = x_3[index_3[<span class="number">0</span>]];</span><br><span class="line">  x_3[index_3[<span class="number">0</span>]] = x_3[<span class="number">0</span>];</span><br><span class="line">  x_3[<span class="number">0</span>] = sum;</span><br><span class="line"></span><br><span class="line">  sum = x_3[index_3[<span class="number">1</span>]];</span><br><span class="line">  x_3[index_3[<span class="number">1</span>]] = x_3[<span class="number">1</span>];</span><br><span class="line">  x_3[<span class="number">1</span>] = sum - mat_3x3[<span class="number">1</span>][<span class="number">0</span>] * x_3[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  sum = x_3[index_3[<span class="number">2</span>]];</span><br><span class="line">  x_3[index_3[<span class="number">2</span>]] = x_3[<span class="number">2</span>];</span><br><span class="line">  x_3[<span class="number">2</span>] = sum - mat_3x3[<span class="number">2</span>][<span class="number">0</span>] * x_3[<span class="number">0</span>] - mat_3x3[<span class="number">2</span>][<span class="number">1</span>] * x_3[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// back substitution</span></span><br><span class="line">  x_3[<span class="number">2</span>] = x_3[<span class="number">2</span>] / mat_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  x_3[<span class="number">1</span>] = (x_3[<span class="number">1</span>] - mat_3x3[<span class="number">1</span>][<span class="number">2</span>] * x_3[<span class="number">2</span>]) / mat_3x3[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  x_3[<span class="number">0</span>] = (x_3[<span class="number">0</span>] - mat_3x3[<span class="number">0</span>][<span class="number">1</span>] * x_3[<span class="number">1</span>] - mat_3x3[<span class="number">0</span>][<span class="number">2</span>] * x_3[<span class="number">2</span>]) / mat_3x3[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linearSolve3x3</span>(<span class="params">mat_3x3, x_3, y_3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a1 = mat_3x3[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> b1 = mat_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> c1 = mat_3x3[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> a2 = mat_3x3[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> b2 = mat_3x3[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> c2 = mat_3x3[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> a3 = mat_3x3[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> b3 = mat_3x3[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> c3 = mat_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the adjoint</span></span><br><span class="line">  <span class="keyword">const</span> d1 = +determinant2x2(b2, b3, c2, c3);</span><br><span class="line">  <span class="keyword">const</span> d2 = -determinant2x2(a2, a3, c2, c3);</span><br><span class="line">  <span class="keyword">const</span> d3 = +determinant2x2(a2, a3, b2, b3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> e1 = -determinant2x2(b1, b3, c1, c3);</span><br><span class="line">  <span class="keyword">const</span> e2 = +determinant2x2(a1, a3, c1, c3);</span><br><span class="line">  <span class="keyword">const</span> e3 = -determinant2x2(a1, a3, b1, b3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f1 = +determinant2x2(b1, b2, c1, c2);</span><br><span class="line">  <span class="keyword">const</span> f2 = -determinant2x2(a1, a2, c1, c2);</span><br><span class="line">  <span class="keyword">const</span> f3 = +determinant2x2(a1, a2, b1, b2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the determinant</span></span><br><span class="line">  <span class="keyword">const</span> det = a1 * d1 + b1 * d2 + c1 * d3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Multiply by the adjoint</span></span><br><span class="line">  <span class="keyword">const</span> v1 = d1 * x_3[<span class="number">0</span>] + e1 * x_3[<span class="number">1</span>] + f1 * x_3[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> v2 = d2 * x_3[<span class="number">0</span>] + e2 * x_3[<span class="number">1</span>] + f2 * x_3[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> v3 = d3 * x_3[<span class="number">0</span>] + e3 * x_3[<span class="number">1</span>] + f3 * x_3[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Divide by the determinant</span></span><br><span class="line">  y_3[<span class="number">0</span>] = v1 / det;</span><br><span class="line">  y_3[<span class="number">1</span>] = v2 / det;</span><br><span class="line">  y_3[<span class="number">2</span>] = v3 / det;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply3x3_vect3</span>(<span class="params">mat_3x3, in_3, out_3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = mat_3x3[<span class="number">0</span>][<span class="number">0</span>] * in_3[<span class="number">0</span>] + mat_3x3[<span class="number">0</span>][<span class="number">1</span>] * in_3[<span class="number">1</span>] + mat_3x3[<span class="number">0</span>][<span class="number">2</span>] * in_3[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> y = mat_3x3[<span class="number">1</span>][<span class="number">0</span>] * in_3[<span class="number">0</span>] + mat_3x3[<span class="number">1</span>][<span class="number">1</span>] * in_3[<span class="number">1</span>] + mat_3x3[<span class="number">1</span>][<span class="number">2</span>] * in_3[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> z = mat_3x3[<span class="number">2</span>][<span class="number">0</span>] * in_3[<span class="number">0</span>] + mat_3x3[<span class="number">2</span>][<span class="number">1</span>] * in_3[<span class="number">1</span>] + mat_3x3[<span class="number">2</span>][<span class="number">2</span>] * in_3[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  out_3[<span class="number">0</span>] = x;</span><br><span class="line">  out_3[<span class="number">1</span>] = y;</span><br><span class="line">  out_3[<span class="number">2</span>] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply3x3_mat3</span>(<span class="params">a_3x3, b_3x3, out_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tmp = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    tmp[<span class="number">0</span>][i] = a_3x3[<span class="number">0</span>][<span class="number">0</span>] * b_3x3[<span class="number">0</span>][i] + a_3x3[<span class="number">0</span>][<span class="number">1</span>] * b_3x3[<span class="number">1</span>][i] + a_3x3[<span class="number">0</span>][<span class="number">2</span>] * b_3x3[<span class="number">2</span>][i];</span><br><span class="line">    tmp[<span class="number">1</span>][i] = a_3x3[<span class="number">1</span>][<span class="number">0</span>] * b_3x3[<span class="number">0</span>][i] + a_3x3[<span class="number">1</span>][<span class="number">1</span>] * b_3x3[<span class="number">1</span>][i] + a_3x3[<span class="number">1</span>][<span class="number">2</span>] * b_3x3[<span class="number">2</span>][i];</span><br><span class="line">    tmp[<span class="number">2</span>][i] = a_3x3[<span class="number">2</span>][<span class="number">0</span>] * b_3x3[<span class="number">0</span>][i] + a_3x3[<span class="number">2</span>][<span class="number">1</span>] * b_3x3[<span class="number">1</span>][i] + a_3x3[<span class="number">2</span>][<span class="number">2</span>] * b_3x3[<span class="number">2</span>][i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    out_3x3[j][<span class="number">0</span>] = tmp[j][<span class="number">0</span>];</span><br><span class="line">    out_3x3[j][<span class="number">1</span>] = tmp[j][<span class="number">1</span>];</span><br><span class="line">    out_3x3[j][<span class="number">2</span>] = tmp[j][<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyMatrix</span>(<span class="params">a, b, rowA, colA, rowB, colB, out_rowXcol</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// we need colA == rowB</span></span><br><span class="line">  <span class="keyword">if</span> (colA !== rowB) &#123;</span><br><span class="line">    vtkErrorMacro(<span class="string">'Number of columns of A must match number of rows of B.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// output matrix is rowA*colB</span></span><br><span class="line">  <span class="comment">// output row</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</span><br><span class="line">    <span class="comment">// output col</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; colB; j++) &#123;</span><br><span class="line">      out_rowXcol[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// sum for this point</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; colA; k++) &#123;</span><br><span class="line">        out_rowXcol[i][j] += a[i][k] * b[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpose3x3</span>(<span class="params">in_3x3, outT_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">  tmp = in_3x3[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  outT_3x3[<span class="number">1</span>][<span class="number">0</span>] = in_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  outT_3x3[<span class="number">0</span>][<span class="number">1</span>] = tmp;</span><br><span class="line">  tmp = in_3x3[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">  outT_3x3[<span class="number">2</span>][<span class="number">0</span>] = in_3x3[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">  outT_3x3[<span class="number">0</span>][<span class="number">2</span>] = tmp;</span><br><span class="line">  tmp = in_3x3[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">  outT_3x3[<span class="number">2</span>][<span class="number">1</span>] = in_3x3[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">  outT_3x3[<span class="number">1</span>][<span class="number">2</span>] = tmp;</span><br><span class="line"></span><br><span class="line">  outT_3x3[<span class="number">0</span>][<span class="number">0</span>] = in_3x3[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  outT_3x3[<span class="number">1</span>][<span class="number">1</span>] = in_3x3[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  outT_3x3[<span class="number">2</span>][<span class="number">2</span>] = in_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invert3x3</span>(<span class="params">in_3x3, outI_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a1 = in_3x3[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> b1 = in_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> c1 = in_3x3[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> a2 = in_3x3[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> b2 = in_3x3[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> c2 = in_3x3[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> a3 = in_3x3[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> b3 = in_3x3[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> c3 = in_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the adjoint</span></span><br><span class="line">  <span class="keyword">const</span> d1 = +determinant2x2(b2, b3, c2, c3);</span><br><span class="line">  <span class="keyword">const</span> d2 = -determinant2x2(a2, a3, c2, c3);</span><br><span class="line">  <span class="keyword">const</span> d3 = +determinant2x2(a2, a3, b2, b3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> e1 = -determinant2x2(b1, b3, c1, c3);</span><br><span class="line">  <span class="keyword">const</span> e2 = +determinant2x2(a1, a3, c1, c3);</span><br><span class="line">  <span class="keyword">const</span> e3 = -determinant2x2(a1, a3, b1, b3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f1 = +determinant2x2(b1, b2, c1, c2);</span><br><span class="line">  <span class="keyword">const</span> f2 = -determinant2x2(a1, a2, c1, c2);</span><br><span class="line">  <span class="keyword">const</span> f3 = +determinant2x2(a1, a2, b1, b2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Divide by the determinant</span></span><br><span class="line">  <span class="keyword">const</span> det = a1 * d1 + b1 * d2 + c1 * d3;</span><br><span class="line"></span><br><span class="line">  outI_3x3[<span class="number">0</span>][<span class="number">0</span>] = d1 / det;</span><br><span class="line">  outI_3x3[<span class="number">1</span>][<span class="number">0</span>] = d2 / det;</span><br><span class="line">  outI_3x3[<span class="number">2</span>][<span class="number">0</span>] = d3 / det;</span><br><span class="line"></span><br><span class="line">  outI_3x3[<span class="number">0</span>][<span class="number">1</span>] = e1 / det;</span><br><span class="line">  outI_3x3[<span class="number">1</span>][<span class="number">1</span>] = e2 / det;</span><br><span class="line">  outI_3x3[<span class="number">2</span>][<span class="number">1</span>] = e3 / det;</span><br><span class="line"></span><br><span class="line">  outI_3x3[<span class="number">0</span>][<span class="number">2</span>] = f1 / det;</span><br><span class="line">  outI_3x3[<span class="number">1</span>][<span class="number">2</span>] = f2 / det;</span><br><span class="line">  outI_3x3[<span class="number">2</span>][<span class="number">2</span>] = f3 / det;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity3x3</span>(<span class="params">mat_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    mat_3x3[i][<span class="number">0</span>] = mat_3x3[i][<span class="number">1</span>] = mat_3x3[i][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    mat_3x3[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determinant3x3</span>(<span class="params">mat_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mat_3x3[<span class="number">0</span>][<span class="number">0</span>] * mat_3x3[<span class="number">1</span>][<span class="number">1</span>] * mat_3x3[<span class="number">2</span>][<span class="number">2</span>] + mat_3x3[<span class="number">1</span>][<span class="number">0</span>] * mat_3x3[<span class="number">2</span>][<span class="number">1</span>] * mat_3x3[<span class="number">0</span>][<span class="number">2</span>] +</span><br><span class="line">    mat_3x3[<span class="number">2</span>][<span class="number">0</span>] * mat_3x3[<span class="number">0</span>][<span class="number">1</span>] * mat_3x3[<span class="number">1</span>][<span class="number">2</span>] - mat_3x3[<span class="number">0</span>][<span class="number">0</span>] * mat_3x3[<span class="number">2</span>][<span class="number">1</span>] * mat_3x3[<span class="number">1</span>][<span class="number">2</span>] -</span><br><span class="line">    mat_3x3[<span class="number">1</span>][<span class="number">0</span>] * mat_3x3[<span class="number">0</span>][<span class="number">1</span>] * mat_3x3[<span class="number">2</span>][<span class="number">2</span>] - mat_3x3[<span class="number">2</span>][<span class="number">0</span>] * mat_3x3[<span class="number">1</span>][<span class="number">1</span>] * mat_3x3[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quaternionToMatrix3x3</span>(<span class="params">quat_4, mat_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ww = quat_4[<span class="number">0</span>] * quat_4[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> wx = quat_4[<span class="number">0</span>] * quat_4[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> wy = quat_4[<span class="number">0</span>] * quat_4[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> wz = quat_4[<span class="number">0</span>] * quat_4[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xx = quat_4[<span class="number">1</span>] * quat_4[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> yy = quat_4[<span class="number">2</span>] * quat_4[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> zz = quat_4[<span class="number">3</span>] * quat_4[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xy = quat_4[<span class="number">1</span>] * quat_4[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> xz = quat_4[<span class="number">1</span>] * quat_4[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">const</span> yz = quat_4[<span class="number">2</span>] * quat_4[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rr = xx + yy + zz;</span><br><span class="line">  <span class="comment">// normalization factor, just in case quaternion was not normalized</span></span><br><span class="line">  <span class="keyword">let</span> f = <span class="number">1</span> / (ww + rr);</span><br><span class="line">  <span class="keyword">const</span> s = (ww - rr) * f;</span><br><span class="line">  f *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  mat_3x3[<span class="number">0</span>][<span class="number">0</span>] = xx * f + s;</span><br><span class="line">  mat_3x3[<span class="number">1</span>][<span class="number">0</span>] = (xy + wz) * f;</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">0</span>] = (xz - wy) * f;</span><br><span class="line"></span><br><span class="line">  mat_3x3[<span class="number">0</span>][<span class="number">1</span>] = (xy - wz) * f;</span><br><span class="line">  mat_3x3[<span class="number">1</span>][<span class="number">1</span>] = yy * f + s;</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">1</span>] = (yz + wx) * f;</span><br><span class="line"></span><br><span class="line">  mat_3x3[<span class="number">0</span>][<span class="number">2</span>] = (xz + wy) * f;</span><br><span class="line">  mat_3x3[<span class="number">1</span>][<span class="number">2</span>] = (yz - wx) * f;</span><br><span class="line">  mat_3x3[<span class="number">2</span>][<span class="number">2</span>] = zz * f + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jacobiN</span>(<span class="params">a, n, w, v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line">  <span class="keyword">let</span> iq;</span><br><span class="line">  <span class="keyword">let</span> ip;</span><br><span class="line">  <span class="keyword">let</span> numPos;</span><br><span class="line">  <span class="keyword">let</span> tresh;</span><br><span class="line">  <span class="keyword">let</span> theta;</span><br><span class="line">  <span class="keyword">let</span> t;</span><br><span class="line">  <span class="keyword">let</span> tau;</span><br><span class="line">  <span class="keyword">let</span> sm;</span><br><span class="line">  <span class="keyword">let</span> s;</span><br><span class="line">  <span class="keyword">let</span> h;</span><br><span class="line">  <span class="keyword">let</span> g;</span><br><span class="line">  <span class="keyword">let</span> c;</span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">  <span class="keyword">const</span> b = createArray(n);</span><br><span class="line">  <span class="keyword">const</span> z = createArray(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vtkROTATE = (aa, ii, jj, kk, ll) =&gt; &#123;</span><br><span class="line">    g = aa[ii][jj];</span><br><span class="line">    h = aa[kk][ll];</span><br><span class="line">    a[ii][jj] = g - s * (h + g * tau);</span><br><span class="line">    a[kk][ll] = h + s * (g - h * tau);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize</span></span><br><span class="line">  <span class="keyword">for</span> (ip = <span class="number">0</span>; ip &lt; n; ip++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (iq = <span class="number">0</span>; iq &lt; n; iq++) &#123;</span><br><span class="line">      v[ip][iq] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[ip][ip] = <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (ip = <span class="number">0</span>; ip &lt; n; ip++) &#123;</span><br><span class="line">    b[ip] = w[ip] = a[ip][ip];</span><br><span class="line">    z[ip] = <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// begin rotation sequence</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; VTK_MAX_ROTATIONS; i++) &#123;</span><br><span class="line">    sm = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ip = <span class="number">0</span>; ip &lt; n - <span class="number">1</span>; ip++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (iq = ip + <span class="number">1</span>; iq &lt; n; iq++) &#123;</span><br><span class="line">        sm += <span class="built_in">Math</span>.abs(a[ip][iq]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sm === <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first 3 sweeps</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      tresh = <span class="number">0.2</span> * sm / (n * n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tresh = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ip = <span class="number">0</span>; ip &lt; n - <span class="number">1</span>; ip++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (iq = ip + <span class="number">1</span>; iq &lt; n; iq++) &#123;</span><br><span class="line">        g = <span class="number">100.0</span> * <span class="built_in">Math</span>.abs(a[ip][iq]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// after 4 sweeps</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">3</span> &amp;&amp; (<span class="built_in">Math</span>.abs(w[ip]) + g) === <span class="built_in">Math</span>.abs(w[ip]) &amp;&amp; (<span class="built_in">Math</span>.abs(w[iq]) + g) === <span class="built_in">Math</span>.abs(w[iq])) &#123;</span><br><span class="line">          a[ip][iq] = <span class="number">0.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(a[ip][iq]) &gt; tresh) &#123;</span><br><span class="line">          h = w[iq] - w[ip];</span><br><span class="line">          <span class="keyword">if</span> ((<span class="built_in">Math</span>.abs(h) + g) === <span class="built_in">Math</span>.abs(h)) &#123;</span><br><span class="line">            t = (a[ip][iq]) / h;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            theta = <span class="number">0.5</span> * h / (a[ip][iq]);</span><br><span class="line">            t = <span class="number">1.0</span> / (<span class="built_in">Math</span>.abs(theta) + <span class="built_in">Math</span>.sqrt(<span class="number">1.0</span> + theta * theta));</span><br><span class="line">            <span class="keyword">if</span> (theta &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">              t = -t;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          c = <span class="number">1.0</span> / <span class="built_in">Math</span>.sqrt(<span class="number">1</span> + t * t);</span><br><span class="line">          s = t * c;</span><br><span class="line">          tau = s / (<span class="number">1.0</span> + c);</span><br><span class="line">          h = t * a[ip][iq];</span><br><span class="line">          z[ip] -= h;</span><br><span class="line">          z[iq] += h;</span><br><span class="line">          w[ip] -= h;</span><br><span class="line">          w[iq] += h;</span><br><span class="line">          a[ip][iq] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ip already shifted left by 1 unit</span></span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= ip - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            vtkROTATE(a, j, ip, j, iq);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ip and iq already shifted left by 1 unit</span></span><br><span class="line">          <span class="keyword">for</span> (j = ip + <span class="number">1</span>; j &lt;= iq - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            vtkROTATE(a, ip, j, j, iq);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// iq already shifted left by 1 unit</span></span><br><span class="line">          <span class="keyword">for</span> (j = iq + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            vtkROTATE(a, ip, j, iq, j);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            vtkROTATE(v, j, ip, j, iq);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ip = <span class="number">0</span>; ip &lt; n; ip++) &#123;</span><br><span class="line">      b[ip] += z[ip];</span><br><span class="line">      w[ip] = b[ip];</span><br><span class="line">      z[ip] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is NEVER called</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= VTK_MAX_ROTATIONS) &#123;</span><br><span class="line">    vtkWarningMacro(<span class="string">'vtkMath::Jacobi: Error extracting eigenfunctions'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sort eigenfunctions: these changes do not affect accuracy</span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// boundary incorrect</span></span><br><span class="line">    k = j;</span><br><span class="line">    tmp = w[k];</span><br><span class="line">    <span class="keyword">for</span> (i = j + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// boundary incorrect, shifted already</span></span><br><span class="line">      <span class="keyword">if</span> (w[i] &gt;= tmp) &#123;</span><br><span class="line">        <span class="comment">// why exchange if same?</span></span><br><span class="line">        k = i;</span><br><span class="line">        tmp = w[k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k !== j) &#123;</span><br><span class="line">      w[k] = w[j];</span><br><span class="line">      w[j] = tmp;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        tmp = v[i][j];</span><br><span class="line">        v[i][j] = v[i][k];</span><br><span class="line">        v[i][k] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insure eigenvector consistency (i.e., Jacobi can compute vectors that</span></span><br><span class="line">  <span class="comment">// are negative of one another (.707,.707,0) and (-.707,-.707,0). This can</span></span><br><span class="line">  <span class="comment">// reek havoc in hyperstreamline/other stuff. We will select the most</span></span><br><span class="line">  <span class="comment">// positive eigenvector.</span></span><br><span class="line">  <span class="keyword">const</span> ceil_half_n = (n &gt;&gt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (numPos = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v[i][j] &gt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        numPos++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    if ( numPos &lt; ceil(double(n)/double(2.0)) )</span></span><br><span class="line">    <span class="keyword">if</span> (numPos &lt; ceil_half_n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        v[i][j] *= <span class="number">-1.0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrix3x3ToQuaternion</span>(<span class="params">mat_3x3, quat_4</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tmp = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// on-diagonal elements</span></span><br><span class="line">  tmp[<span class="number">0</span>][<span class="number">0</span>] = mat_3x3[<span class="number">0</span>][<span class="number">0</span>] + mat_3x3[<span class="number">1</span>][<span class="number">1</span>] + mat_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  tmp[<span class="number">1</span>][<span class="number">1</span>] = mat_3x3[<span class="number">0</span>][<span class="number">0</span>] - mat_3x3[<span class="number">1</span>][<span class="number">1</span>] - mat_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  tmp[<span class="number">2</span>][<span class="number">2</span>] = -mat_3x3[<span class="number">0</span>][<span class="number">0</span>] + mat_3x3[<span class="number">1</span>][<span class="number">1</span>] - mat_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  tmp[<span class="number">3</span>][<span class="number">3</span>] = -mat_3x3[<span class="number">0</span>][<span class="number">0</span>] - mat_3x3[<span class="number">1</span>][<span class="number">1</span>] + mat_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// off-diagonal elements</span></span><br><span class="line">  tmp[<span class="number">0</span>][<span class="number">1</span>] = tmp[<span class="number">1</span>][<span class="number">0</span>] = mat_3x3[<span class="number">2</span>][<span class="number">1</span>] - mat_3x3[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">  tmp[<span class="number">0</span>][<span class="number">2</span>] = tmp[<span class="number">2</span>][<span class="number">0</span>] = mat_3x3[<span class="number">0</span>][<span class="number">2</span>] - mat_3x3[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">  tmp[<span class="number">0</span>][<span class="number">3</span>] = tmp[<span class="number">3</span>][<span class="number">0</span>] = mat_3x3[<span class="number">1</span>][<span class="number">0</span>] - mat_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  tmp[<span class="number">1</span>][<span class="number">2</span>] = tmp[<span class="number">2</span>][<span class="number">1</span>] = mat_3x3[<span class="number">1</span>][<span class="number">0</span>] + mat_3x3[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  tmp[<span class="number">1</span>][<span class="number">3</span>] = tmp[<span class="number">3</span>][<span class="number">1</span>] = mat_3x3[<span class="number">0</span>][<span class="number">2</span>] + mat_3x3[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">  tmp[<span class="number">2</span>][<span class="number">3</span>] = tmp[<span class="number">3</span>][<span class="number">2</span>] = mat_3x3[<span class="number">2</span>][<span class="number">1</span>] + mat_3x3[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> eigenvectors = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> eigenvalues = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert into format that JacobiN can use,</span></span><br><span class="line">  <span class="comment">// then use Jacobi to find eigenvalues and eigenvectors</span></span><br><span class="line">  <span class="keyword">const</span> NTemp = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> eigenvectorsTemp = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    NTemp[i] = tmp[i];</span><br><span class="line">    eigenvectorsTemp[i] = eigenvectors[i];</span><br><span class="line">  &#125;</span><br><span class="line">  jacobiN(NTemp, <span class="number">4</span>, eigenvalues, eigenvectorsTemp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the first eigenvector is the one we want</span></span><br><span class="line">  quat_4[<span class="number">0</span>] = eigenvectors[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  quat_4[<span class="number">1</span>] = eigenvectors[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  quat_4[<span class="number">2</span>] = eigenvectors[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">  quat_4[<span class="number">3</span>] = eigenvectors[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyQuaternion</span>(<span class="params">quat_1, quat_2, quat_out</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ww = quat_1[<span class="number">0</span>] * quat_2[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> wx = quat_1[<span class="number">0</span>] * quat_2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> wy = quat_1[<span class="number">0</span>] * quat_2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> wz = quat_1[<span class="number">0</span>] * quat_2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xw = quat_1[<span class="number">1</span>] * quat_2[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> xx = quat_1[<span class="number">1</span>] * quat_2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> xy = quat_1[<span class="number">1</span>] * quat_2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> xz = quat_1[<span class="number">1</span>] * quat_2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> yw = quat_1[<span class="number">2</span>] * quat_2[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> yx = quat_1[<span class="number">2</span>] * quat_2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> yy = quat_1[<span class="number">2</span>] * quat_2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> yz = quat_1[<span class="number">2</span>] * quat_2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> zw = quat_1[<span class="number">3</span>] * quat_2[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> zx = quat_1[<span class="number">3</span>] * quat_2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> zy = quat_1[<span class="number">3</span>] * quat_2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> zz = quat_1[<span class="number">3</span>] * quat_2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  quat_out[<span class="number">0</span>] = ww - xx - yy - zz;</span><br><span class="line">  quat_out[<span class="number">1</span>] = wx + xw + yz - zy;</span><br><span class="line">  quat_out[<span class="number">2</span>] = wy - xz + yw + zx;</span><br><span class="line">  quat_out[<span class="number">3</span>] = wz + xy - yx + zw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orthogonalize3x3</span>(<span class="params">a_3x3, out_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// copy the matrix</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    out_3x3[<span class="number">0</span>][i] = a_3x3[<span class="number">0</span>][i];</span><br><span class="line">    out_3x3[<span class="number">1</span>][i] = a_3x3[<span class="number">1</span>][i];</span><br><span class="line">    out_3x3[<span class="number">2</span>][i] = a_3x3[<span class="number">2</span>][i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pivot the matrix to improve accuracy</span></span><br><span class="line">  <span class="keyword">const</span> scale = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> index = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> largest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop over rows to get implicit scaling information</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = <span class="built_in">Math</span>.abs(out_3x3[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> x2 = <span class="built_in">Math</span>.abs(out_3x3[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> x3 = <span class="built_in">Math</span>.abs(out_3x3[i][<span class="number">2</span>]);</span><br><span class="line">    largest = (x2 &gt; x1 ? x2 : x1);</span><br><span class="line">    largest = (x3 &gt; largest ? x3 : largest);</span><br><span class="line">    scale[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (largest !== <span class="number">0</span>) &#123;</span><br><span class="line">      scale[i] /= largest;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// first column</span></span><br><span class="line">  <span class="keyword">const</span> x1 = <span class="built_in">Math</span>.abs(out_3x3[<span class="number">0</span>][<span class="number">0</span>]) * scale[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> x2 = <span class="built_in">Math</span>.abs(out_3x3[<span class="number">1</span>][<span class="number">0</span>]) * scale[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> x3 = <span class="built_in">Math</span>.abs(out_3x3[<span class="number">2</span>][<span class="number">0</span>]) * scale[<span class="number">2</span>];</span><br><span class="line">  index[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  largest = x1;</span><br><span class="line">  <span class="keyword">if</span> (x2 &gt;= largest) &#123;</span><br><span class="line">    largest = x2;</span><br><span class="line">    index[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x3 &gt;= largest) &#123;</span><br><span class="line">    index[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (index[<span class="number">0</span>] !== <span class="number">0</span>) &#123;</span><br><span class="line">    vtkSwapVectors3(out_3x3[index[<span class="number">0</span>]], out_3x3[<span class="number">0</span>]);</span><br><span class="line">    scale[index[<span class="number">0</span>]] = scale[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// second column</span></span><br><span class="line">  <span class="keyword">const</span> y2 = <span class="built_in">Math</span>.abs(out_3x3[<span class="number">1</span>][<span class="number">1</span>]) * scale[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> y3 = <span class="built_in">Math</span>.abs(out_3x3[<span class="number">2</span>][<span class="number">1</span>]) * scale[<span class="number">2</span>];</span><br><span class="line">  index[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  largest = y2;</span><br><span class="line">  <span class="keyword">if</span> (y3 &gt;= largest) &#123;</span><br><span class="line">    index[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    vtkSwapVectors3(out_3x3[<span class="number">2</span>], out_3x3[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// third column</span></span><br><span class="line">  index[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A quaternion can only describe a pure rotation, not</span></span><br><span class="line">  <span class="comment">// a rotation with a flip, therefore the flip must be</span></span><br><span class="line">  <span class="comment">// removed before the matrix is converted to a quaternion.</span></span><br><span class="line">  <span class="keyword">let</span> flip = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (determinant3x3(out_3x3) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    flip = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      out_3x3[<span class="number">0</span>][i] = -out_3x3[<span class="number">0</span>][i];</span><br><span class="line">      out_3x3[<span class="number">1</span>][i] = -out_3x3[<span class="number">1</span>][i];</span><br><span class="line">      out_3x3[<span class="number">2</span>][i] = -out_3x3[<span class="number">2</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do orthogonalization using a quaternion intermediate</span></span><br><span class="line">  <span class="comment">// (this, essentially, does the orthogonalization via</span></span><br><span class="line">  <span class="comment">// diagonalization of an appropriately constructed symmetric</span></span><br><span class="line">  <span class="comment">// 4x4 matrix rather than by doing SVD of the 3x3 matrix)</span></span><br><span class="line">  <span class="keyword">const</span> quat = createArray(<span class="number">4</span>);</span><br><span class="line">  matrix3x3ToQuaternion(out_3x3, quat);</span><br><span class="line">  quaternionToMatrix3x3(quat, out_3x3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put the flip back into the orthogonalized matrix.</span></span><br><span class="line">  <span class="keyword">if</span> (flip) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      out_3x3[<span class="number">0</span>][i] = -out_3x3[<span class="number">0</span>][i];</span><br><span class="line">      out_3x3[<span class="number">1</span>][i] = -out_3x3[<span class="number">1</span>][i];</span><br><span class="line">      out_3x3[<span class="number">2</span>][i] = -out_3x3[<span class="number">2</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Undo the pivoting</span></span><br><span class="line">  <span class="keyword">if</span> (index[<span class="number">1</span>] !== <span class="number">1</span>) &#123;</span><br><span class="line">    vtkSwapVectors3(out_3x3[index[<span class="number">1</span>]], out_3x3[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (index[<span class="number">0</span>] !== <span class="number">0</span>) &#123;</span><br><span class="line">    vtkSwapVectors3(out_3x3[index[<span class="number">0</span>]], out_3x3[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diagonalize3x3</span>(<span class="params">a_3x3, w_3, v_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line">  <span class="keyword">let</span> maxI;</span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">  <span class="keyword">let</span> maxVal;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do the matrix[3][3] to **matrix conversion for Jacobi</span></span><br><span class="line">  <span class="keyword">const</span> C = [</span><br><span class="line">    createArray(<span class="number">3</span>),</span><br><span class="line">    createArray(<span class="number">3</span>),</span><br><span class="line">    createArray(<span class="number">3</span>),</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> ATemp = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> VTemp = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    C[i][<span class="number">0</span>] = a_3x3[i][<span class="number">0</span>];</span><br><span class="line">    C[i][<span class="number">1</span>] = a_3x3[i][<span class="number">1</span>];</span><br><span class="line">    C[i][<span class="number">2</span>] = a_3x3[i][<span class="number">2</span>];</span><br><span class="line">    ATemp[i] = C[i];</span><br><span class="line">    VTemp[i] = v_3x3[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// diagonalize using Jacobi</span></span><br><span class="line">  jacobiN(ATemp, <span class="number">3</span>, w_3, VTemp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if all the eigenvalues are the same, return identity matrix</span></span><br><span class="line">  <span class="keyword">if</span> (w_3[<span class="number">0</span>] === w_3[<span class="number">1</span>] &amp;&amp; w_3[<span class="number">0</span>] === w_3[<span class="number">2</span>]) &#123;</span><br><span class="line">    identity3x3(v_3x3);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transpose temporarily, it makes it easier to sort the eigenvectors</span></span><br><span class="line">  transpose3x3(v_3x3, v_3x3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if two eigenvalues are the same, re-orthogonalize to optimally line</span></span><br><span class="line">  <span class="comment">// up the eigenvectors with the x, y, and z axes</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// two eigenvalues are the same</span></span><br><span class="line">    <span class="keyword">if</span> (w_3[(i + <span class="number">1</span>) % <span class="number">3</span>] === w_3[(i + <span class="number">2</span>) % <span class="number">3</span>]) &#123;</span><br><span class="line">      <span class="comment">// find maximum element of the independent eigenvector</span></span><br><span class="line">      maxVal = <span class="built_in">Math</span>.abs(v_3x3[i][<span class="number">0</span>]);</span><br><span class="line">      maxI = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; (tmp = <span class="built_in">Math</span>.abs(v_3x3[i][j]))) &#123;</span><br><span class="line">          maxVal = tmp;</span><br><span class="line">          maxI = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// swap the eigenvector into its proper position</span></span><br><span class="line">      <span class="keyword">if</span> (maxI !== i) &#123;</span><br><span class="line">        tmp = w_3[maxI];</span><br><span class="line">        w_3[maxI] = w_3[i];</span><br><span class="line">        w_3[i] = tmp;</span><br><span class="line">        vtkSwapVectors3(v_3x3[i], v_3x3[maxI]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// maximum element of eigenvector should be positive</span></span><br><span class="line">      <span class="keyword">if</span> (v_3x3[maxI][maxI] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        v_3x3[maxI][<span class="number">0</span>] = -v_3x3[maxI][<span class="number">0</span>];</span><br><span class="line">        v_3x3[maxI][<span class="number">1</span>] = -v_3x3[maxI][<span class="number">1</span>];</span><br><span class="line">        v_3x3[maxI][<span class="number">2</span>] = -v_3x3[maxI][<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// re-orthogonalize the other two eigenvectors</span></span><br><span class="line">      j = (maxI + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">      k = (maxI + <span class="number">2</span>) % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      v_3x3[j][<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">      v_3x3[j][<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">      v_3x3[j][<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line">      v_3x3[j][j] = <span class="number">1.0</span>;</span><br><span class="line">      cross(v_3x3[maxI], v_3x3[j], v_3x3[k]);</span><br><span class="line">      normalize(v_3x3[k]);</span><br><span class="line">      cross(v_3x3[k], v_3x3[maxI], v_3x3[j]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// transpose vectors back to columns</span></span><br><span class="line">      transpose3x3(v_3x3, v_3x3);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the three eigenvalues are different, just sort the eigenvectors</span></span><br><span class="line">  <span class="comment">// to align them with the x, y, and z axes</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the vector with the largest x element, make that vector</span></span><br><span class="line">  <span class="comment">// the first vector</span></span><br><span class="line">  maxVal = <span class="built_in">Math</span>.abs(v_3x3[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  maxI = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxVal &lt; (tmp = <span class="built_in">Math</span>.abs(v_3x3[i][<span class="number">0</span>]))) &#123;</span><br><span class="line">      maxVal = tmp;</span><br><span class="line">      maxI = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// swap eigenvalue and eigenvector</span></span><br><span class="line">  <span class="keyword">if</span> (maxI !== <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = w_3[maxI];</span><br><span class="line">    w_3[maxI] = w_3[<span class="number">0</span>];</span><br><span class="line">    w_3[<span class="number">0</span>] = tmp;</span><br><span class="line">    vtkSwapVectors3(v_3x3[maxI], v_3x3[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do the same for the y element</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(v_3x3[<span class="number">1</span>][<span class="number">1</span>]) &lt; <span class="built_in">Math</span>.abs(v_3x3[<span class="number">2</span>][<span class="number">1</span>])) &#123;</span><br><span class="line">    tmp = w_3[<span class="number">2</span>];</span><br><span class="line">    w_3[<span class="number">2</span>] = w_3[<span class="number">1</span>];</span><br><span class="line">    w_3[<span class="number">1</span>] = tmp;</span><br><span class="line">    vtkSwapVectors3(v_3x3[<span class="number">2</span>], v_3x3[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ensure that the sign of the eigenvectors is correct</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v_3x3[i][i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      v_3x3[i][<span class="number">0</span>] = -v_3x3[i][<span class="number">0</span>];</span><br><span class="line">      v_3x3[i][<span class="number">1</span>] = -v_3x3[i][<span class="number">1</span>];</span><br><span class="line">      v_3x3[i][<span class="number">2</span>] = -v_3x3[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set sign of final eigenvector to ensure that determinant is positive</span></span><br><span class="line">  <span class="keyword">if</span> (determinant3x3(v_3x3) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    v_3x3[<span class="number">2</span>][<span class="number">0</span>] = -v_3x3[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    v_3x3[<span class="number">2</span>][<span class="number">1</span>] = -v_3x3[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    v_3x3[<span class="number">2</span>][<span class="number">2</span>] = -v_3x3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transpose the eigenvectors back again</span></span><br><span class="line">  transpose3x3(v_3x3, v_3x3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singularValueDecomposition3x3</span>(<span class="params">a_3x3, u_3x3, w_3, vT_3x3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">const</span> B = [createArray(<span class="number">3</span>), createArray(<span class="number">3</span>), createArray(<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy so that A can be used for U or VT without risk</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    B[<span class="number">0</span>][i] = a_3x3[<span class="number">0</span>][i];</span><br><span class="line">    B[<span class="number">1</span>][i] = a_3x3[<span class="number">1</span>][i];</span><br><span class="line">    B[<span class="number">2</span>][i] = a_3x3[<span class="number">2</span>][i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// temporarily flip if determinant is negative</span></span><br><span class="line">  <span class="keyword">const</span> d = determinant3x3(B);</span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      B[<span class="number">0</span>][i] = -B[<span class="number">0</span>][i];</span><br><span class="line">      B[<span class="number">1</span>][i] = -B[<span class="number">1</span>][i];</span><br><span class="line">      B[<span class="number">2</span>][i] = -B[<span class="number">2</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// orthogonalize, diagonalize, etc.</span></span><br><span class="line">  orthogonalize3x3(B, u_3x3);</span><br><span class="line">  transpose3x3(B, B);</span><br><span class="line">  multiply3x3_mat3(B, u_3x3, vT_3x3);</span><br><span class="line">  diagonalize3x3(vT_3x3, w_3, vT_3x3);</span><br><span class="line">  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);</span><br><span class="line">  transpose3x3(vT_3x3, vT_3x3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// re-create the flip</span></span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    w_3[<span class="number">0</span>] = -w_3[<span class="number">0</span>];</span><br><span class="line">    w_3[<span class="number">1</span>] = -w_3[<span class="number">1</span>];</span><br><span class="line">    w_3[<span class="number">2</span>] = -w_3[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">luFactorLinearSystem</span>(<span class="params">A, index, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line">  <span class="keyword">let</span> largest;</span><br><span class="line">  <span class="keyword">let</span> maxI = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum;</span><br><span class="line">  <span class="keyword">let</span> temp1;</span><br><span class="line">  <span class="keyword">let</span> temp2;</span><br><span class="line">  <span class="keyword">const</span> scale = createArray(size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Loop over rows to get implicit scaling information</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (largest = <span class="number">0.0</span>, j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((temp2 = <span class="built_in">Math</span>.abs(A[i][j])) &gt; largest) &#123;</span><br><span class="line">        largest = temp2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest === <span class="number">0.0</span>) &#123;</span><br><span class="line">      vtkWarningMacro(<span class="string">'Unable to factor linear system'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scale[i] = <span class="number">1.0</span> / largest;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Loop over all columns using Crout's method</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">      sum = A[i][j];</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">        sum -= A[i][k] * A[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">      A[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Begin search for largest pivot element</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (largest = <span class="number">0.0</span>, i = j; i &lt; size; i++) &#123;</span><br><span class="line">      sum = A[i][j];</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">        sum -= A[i][k] * A[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">      A[i][j] = sum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((temp1 = scale[i] * <span class="built_in">Math</span>.abs(sum)) &gt;= largest) &#123;</span><br><span class="line">        largest = temp1;</span><br><span class="line">        maxI = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check for row interchange</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (j !== maxI) &#123;</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">        temp1 = A[maxI][k];</span><br><span class="line">        A[maxI][k] = A[j][k];</span><br><span class="line">        A[j][k] = temp1;</span><br><span class="line">      &#125;</span><br><span class="line">      scale[maxI] = scale[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Divide by pivot element and perform elimination</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    index[j] = maxI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(A[j][j]) &lt;= VTK_SMALL_NUMBER) &#123;</span><br><span class="line">      vtkWarningMacro(<span class="string">'Unable to factor linear system'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j !== (size - <span class="number">1</span>)) &#123;</span><br><span class="line">      temp1 = <span class="number">1.0</span> / A[j][j];</span><br><span class="line">      <span class="keyword">for</span> (i = j + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        A[i][j] *= temp1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">luSolveLinearSystem</span>(<span class="params">A, index, x, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">let</span> ii;</span><br><span class="line">  <span class="keyword">let</span> idx;</span><br><span class="line">  <span class="keyword">let</span> sum;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Proceed with forward and backsubstitution for L and U</span></span><br><span class="line">  <span class="comment">// matrices.  First, forward substitution.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (ii = <span class="number">-1</span>, i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    idx = index[i];</span><br><span class="line">    sum = x[idx];</span><br><span class="line">    x[idx] = x[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ii &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = ii; j &lt;= (i - <span class="number">1</span>); j++) &#123;</span><br><span class="line">        sum -= A[i][j] * x[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum !== <span class="number">0.0</span>) &#123;</span><br><span class="line">      ii = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x[i] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Now, back substitution</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sum = x[i];</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">      sum -= A[i][j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    x[i] = sum / A[i][i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solveLinearSystem</span>(<span class="params">A, x, size</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if we solving something simple, just solve it</span></span><br><span class="line">  <span class="keyword">if</span> (size === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> y = createArray(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> det = determinant2x2(A[<span class="number">0</span>][<span class="number">0</span>], A[<span class="number">0</span>][<span class="number">1</span>], A[<span class="number">1</span>][<span class="number">0</span>], A[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (det === <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// Unable to solve linear system</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y[<span class="number">0</span>] = (A[<span class="number">1</span>][<span class="number">1</span>] * x[<span class="number">0</span>] - A[<span class="number">0</span>][<span class="number">1</span>] * x[<span class="number">1</span>]) / det;</span><br><span class="line">    y[<span class="number">1</span>] = (-A[<span class="number">1</span>][<span class="number">0</span>] * x[<span class="number">0</span>] + A[<span class="number">0</span>][<span class="number">0</span>] * x[<span class="number">1</span>]) / det;</span><br><span class="line"></span><br><span class="line">    x[<span class="number">0</span>] = y[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">1</span>] = y[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[<span class="number">0</span>][<span class="number">0</span>] === <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// Unable to solve linear system</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x[<span class="number">0</span>] /= A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// System of equations is not trivial, use Crout's method</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check on allocation of working vectors</span></span><br><span class="line">  <span class="keyword">const</span> index = createArray(size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factor and solve matrix</span></span><br><span class="line">  <span class="keyword">if</span> (luFactorLinearSystem(A, index, size) === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  luSolveLinearSystem(A, index, x, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertMatrix</span>(<span class="params">A, AI, size, index = null, column = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tmp1Size = index || createArray(size);</span><br><span class="line">  <span class="keyword">const</span> tmp2Size = column || createArray(size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factor matrix; then begin solving for inverse one column at a time.</span></span><br><span class="line">  <span class="comment">// Note: tmp1Size returned value is used later, tmp2Size is just working</span></span><br><span class="line">  <span class="comment">// memory whose values are not used in LUSolveLinearSystem</span></span><br><span class="line">  <span class="keyword">if</span> (luFactorLinearSystem(A, tmp1Size, size, tmp2Size) === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      tmp2Size[i] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp2Size[j] = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      AI[i][j] = tmp2Size[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">estimateMatrixCondition</span>(<span class="params">A, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> minValue = +<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">let</span> maxValue = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the maximum value</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(A[i][j]) &gt; max) &#123;</span><br><span class="line">        maxValue = <span class="built_in">Math</span>.abs(A[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the minimum diagonal value</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(A[i][i]) &lt; min) &#123;</span><br><span class="line">      minValue = <span class="built_in">Math</span>.abs(A[i][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (minValue === <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (maxValue / minValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jacobi</span>(<span class="params">a_3x3, w, v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jacobiN(a_3x3, <span class="number">3</span>, w, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solveHomogeneousLeastSquares</span>(<span class="params">numberOfSamples, xt, xOrder, mt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// check dimensional consistency</span></span><br><span class="line">  <span class="keyword">if</span> (numberOfSamples &lt; xOrder) &#123;</span><br><span class="line">    vtkWarningMacro(<span class="string">'Insufficient number of samples. Underdetermined.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up intermediate variables</span></span><br><span class="line">  <span class="comment">// Allocate matrix to hold X times transpose of X</span></span><br><span class="line">  <span class="keyword">const</span> XXt = createArray(xOrder); <span class="comment">// size x by x</span></span><br><span class="line">  <span class="comment">// Allocate the array of eigenvalues and eigenvectors</span></span><br><span class="line">  <span class="keyword">const</span> eigenvals = createArray(xOrder);</span><br><span class="line">  <span class="keyword">const</span> eigenvecs = createArray(xOrder);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear the upper triangular region (and btw, allocate the eigenvecs as well)</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">    eigenvecs[i] = createArray(xOrder);</span><br><span class="line">    XXt[i] = createArray(xOrder);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; xOrder; j++) &#123;</span><br><span class="line">      XXt[i][j] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate XXt upper half only, due to symmetry</span></span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; numberOfSamples; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = i; j &lt; xOrder; j++) &#123;</span><br><span class="line">        XXt[i][j] += xt[k][i] * xt[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now fill in the lower half of the XXt matrix</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      XXt[i][j] = XXt[j][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the eigenvectors and eigenvalues</span></span><br><span class="line">  jacobiN(XXt, xOrder, eigenvals, eigenvecs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Smallest eigenval is at the end of the list (xOrder-1), and solution is</span></span><br><span class="line">  <span class="comment">// corresponding eigenvec.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">    mt[i][<span class="number">0</span>] = eigenvecs[i][xOrder - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solveLeastSquares</span>(<span class="params">numberOfSamples, xt, xOrder, yt, yOrder, mt, checkHomogeneous = true</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// check dimensional consistency</span></span><br><span class="line">  <span class="keyword">if</span> ((numberOfSamples &lt; xOrder) || (numberOfSamples &lt; yOrder)) &#123;</span><br><span class="line">    vtkWarningMacro(<span class="string">'Insufficient number of samples. Underdetermined.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> homogenFlags = createArray(yOrder);</span><br><span class="line">  <span class="keyword">let</span> allHomogeneous = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> hmt;</span><br><span class="line">  <span class="keyword">let</span> homogRC = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> j;</span><br><span class="line">  <span class="keyword">let</span> k;</span><br><span class="line">  <span class="keyword">let</span> someHomogeneous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ok, first init some flags check and see if all the systems are homogeneous</span></span><br><span class="line">  <span class="keyword">if</span> (checkHomogeneous) &#123;</span><br><span class="line">    <span class="comment">// If Y' is zero, it's a homogeneous system and can't be solved via</span></span><br><span class="line">    <span class="comment">// the pseudoinverse method. Detect this case, warn the user, and</span></span><br><span class="line">    <span class="comment">// invoke SolveHomogeneousLeastSquares instead. Note that it doesn't</span></span><br><span class="line">    <span class="comment">// really make much sense for yOrder to be greater than one in this case,</span></span><br><span class="line">    <span class="comment">// since that's just yOrder occurrences of a 0 vector on the RHS, but</span></span><br><span class="line">    <span class="comment">// we allow it anyway. N</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize homogeneous flags on a per-right-hand-side basis</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">      homogenFlags[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numberOfSamples; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(yt[i][j]) &gt; VTK_SMALL_NUMBER) &#123;</span><br><span class="line">          allHomogeneous = <span class="number">0</span>;</span><br><span class="line">          homogenFlags[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we've got one system, and it's homogeneous, do it and bail out quickly.</span></span><br><span class="line">    <span class="keyword">if</span> (allHomogeneous &amp;&amp; yOrder === <span class="number">1</span>) &#123;</span><br><span class="line">      vtkWarningMacro(<span class="string">'Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()'</span>);</span><br><span class="line">      <span class="keyword">return</span> solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok, we've got more than one system of equations.</span></span><br><span class="line">    <span class="comment">// Figure out if we need to calculate the homogeneous equation solution for</span></span><br><span class="line">    <span class="comment">// any of them.</span></span><br><span class="line">    <span class="keyword">if</span> (allHomogeneous) &#123;</span><br><span class="line">      someHomogeneous = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (homogenFlags[j]) &#123;</span><br><span class="line">          someHomogeneous = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If necessary, solve the homogeneous problem</span></span><br><span class="line">  <span class="keyword">if</span> (someHomogeneous) &#123;</span><br><span class="line">    <span class="comment">// hmt is the homogeneous equation version of mt, the general solution.</span></span><br><span class="line">    hmt = createArray(xOrder);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; xOrder; j++) &#123;</span><br><span class="line">      <span class="comment">// Only allocate 1 here, not yOrder, because here we're going to solve</span></span><br><span class="line">      <span class="comment">// just the one homogeneous equation subset of the entire problem</span></span><br><span class="line">      hmt[j] = [<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok, solve the homogeneous problem</span></span><br><span class="line">    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up intermediate variables</span></span><br><span class="line">  <span class="keyword">const</span> XXt = createArray(xOrder); <span class="comment">// size x by x</span></span><br><span class="line">  <span class="keyword">const</span> XXtI = createArray(xOrder); <span class="comment">// size x by x</span></span><br><span class="line">  <span class="keyword">const</span> XYt = createArray(xOrder); <span class="comment">// size x by y</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">    XXt[i] = createArray(xOrder);</span><br><span class="line">    XXtI[i] = createArray(xOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; xOrder; j++) &#123;</span><br><span class="line">      XXt[i][j] = <span class="number">0.0</span>;</span><br><span class="line">      XXtI[i][j] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XYt[i] = createArray(yOrder);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">      XYt[i][j] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// first find the pseudoinverse matrix</span></span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; numberOfSamples; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">      <span class="comment">// first calculate the XXt matrix, only do the upper half (symmetrical)</span></span><br><span class="line">      <span class="keyword">for</span> (j = i; j &lt; xOrder; j++) &#123;</span><br><span class="line">        XXt[i][j] += xt[k][i] * xt[k][j];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// now calculate the XYt matrix</span></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">        XYt[i][j] += xt[k][i] * yt[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// now fill in the lower half of the XXt matrix</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      XXt[i][j] = XXt[j][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> successFlag = invertMatrix(XXt, XXtI, xOrder);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next get the inverse of XXt</span></span><br><span class="line">  <span class="keyword">if</span> (successFlag) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">        mt[i][j] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; xOrder; k++) &#123;</span><br><span class="line">          mt[i][j] += XXtI[i][k] * XYt[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fix up any of the solutions that correspond to the homogeneous equation</span></span><br><span class="line">  <span class="comment">// problem.</span></span><br><span class="line">  <span class="keyword">if</span> (someHomogeneous) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; yOrder; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (homogenFlags[j]) &#123;</span><br><span class="line">        <span class="comment">// Fix this one</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xOrder; i++) &#123;</span><br><span class="line">          mt[i][j] = hmt[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (someHomogeneous) &#123;</span><br><span class="line">    <span class="keyword">return</span> homogRC &amp;&amp; successFlag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> successFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2hsv</span>(<span class="params">rgb, hsv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> h;</span><br><span class="line">  <span class="keyword">let</span> s;</span><br><span class="line">  <span class="keyword">const</span> [r, g, b] = rgb;</span><br><span class="line">  <span class="keyword">const</span> onethird = <span class="number">1.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">const</span> onesixth = <span class="number">1.0</span> / <span class="number">6.0</span>;</span><br><span class="line">  <span class="keyword">const</span> twothird = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cmax = r;</span><br><span class="line">  <span class="keyword">let</span> cmin = r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g &gt; cmax) &#123;</span><br><span class="line">    cmax = g;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g &lt; cmin) &#123;</span><br><span class="line">    cmin = g;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; cmax) &#123;</span><br><span class="line">    cmax = b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; cmin) &#123;</span><br><span class="line">    cmin = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> v = cmax;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (v &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    s = (cmax - cmin) / cmax;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s = <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r === cmax) &#123;</span><br><span class="line">      h = onesixth * (g - b) / (cmax - cmin);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g === cmax) &#123;</span><br><span class="line">      h = onethird + onesixth * (b - r) / (cmax - cmin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      h = twothird + onesixth * (r - g) / (cmax - cmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">      h += <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    h = <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the values back to the array</span></span><br><span class="line">  hsv[<span class="number">0</span>] = h;</span><br><span class="line">  hsv[<span class="number">1</span>] = s;</span><br><span class="line">  hsv[<span class="number">2</span>] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hsv2rgb</span>(<span class="params">hsv, rgb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [h, s, v] = hsv;</span><br><span class="line">  <span class="keyword">const</span> onethird = <span class="number">1.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">const</span> onesixth = <span class="number">1.0</span> / <span class="number">6.0</span>;</span><br><span class="line">  <span class="keyword">const</span> twothird = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">const</span> fivesixth = <span class="number">5.0</span> / <span class="number">6.0</span>;</span><br><span class="line">  <span class="keyword">let</span> r;</span><br><span class="line">  <span class="keyword">let</span> g;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute RGB from HSV</span></span><br><span class="line">  <span class="keyword">if</span> (h &gt; onesixth &amp;&amp; h &lt;= onethird) &#123;</span><br><span class="line">    <span class="comment">// green/red</span></span><br><span class="line">    g = <span class="number">1.0</span>;</span><br><span class="line">    r = (onethird - h) / onesixth;</span><br><span class="line">    b = <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h &gt; onethird &amp;&amp; h &lt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="comment">// green/blue</span></span><br><span class="line">    g = <span class="number">1.0</span>;</span><br><span class="line">    b = (h - onethird) / onesixth;</span><br><span class="line">    r = <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h &gt; <span class="number">0.5</span> &amp;&amp; h &lt;= twothird) &#123;</span><br><span class="line">    <span class="comment">// blue/green</span></span><br><span class="line">    b = <span class="number">1.0</span>;</span><br><span class="line">    g = (twothird - h) / onesixth;</span><br><span class="line">    r = <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h &gt; twothird &amp;&amp; h &lt;= fivesixth) &#123; <span class="comment">// blue/red</span></span><br><span class="line">    b = <span class="number">1.0</span>;</span><br><span class="line">    r = (h - twothird) / onesixth;</span><br><span class="line">    g = <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h &gt; fivesixth &amp;&amp; h &lt;= <span class="number">1.0</span>) &#123; <span class="comment">// red/blue</span></span><br><span class="line">    r = <span class="number">1.0</span>;</span><br><span class="line">    b = (<span class="number">1.0</span> - h) / onesixth;</span><br><span class="line">    g = <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// red/green</span></span><br><span class="line">    r = <span class="number">1.0</span>;</span><br><span class="line">    g = h / onesixth;</span><br><span class="line">    b = <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add Saturation to the equation.</span></span><br><span class="line">  r = (s * r + (<span class="number">1.0</span> - s));</span><br><span class="line">  g = (s * g + (<span class="number">1.0</span> - s));</span><br><span class="line">  b = (s * b + (<span class="number">1.0</span> - s));</span><br><span class="line"></span><br><span class="line">  r *= v;</span><br><span class="line">  g *= v;</span><br><span class="line">  b *= v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign back to the array</span></span><br><span class="line">  rgb[<span class="number">0</span>] = r;</span><br><span class="line">  rgb[<span class="number">1</span>] = g;</span><br><span class="line">  rgb[<span class="number">2</span>] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lab2xyz</span>(<span class="params">lab, xyz</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// LAB to XYZ</span></span><br><span class="line">  <span class="keyword">const</span> [L, a, b] = lab;</span><br><span class="line">  <span class="keyword">let</span> var_Y = (L + <span class="number">16</span>) / <span class="number">116</span>;</span><br><span class="line">  <span class="keyword">let</span> var_X = a / <span class="number">500</span> + var_Y;</span><br><span class="line">  <span class="keyword">let</span> var_Z = var_Y - b / <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.pow(var_Y, <span class="number">3</span>) &gt; <span class="number">0.008856</span>) &#123;</span><br><span class="line">    var_Y = <span class="built_in">Math</span>.pow(var_Y, <span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var_Y = (var_Y - <span class="number">16.0</span> / <span class="number">116.0</span>) / <span class="number">7.787</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.pow(var_X, <span class="number">3</span>) &gt; <span class="number">0.008856</span>) &#123;</span><br><span class="line">    var_X = <span class="built_in">Math</span>.pow(var_X, <span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var_X = (var_X - <span class="number">16.0</span> / <span class="number">116.0</span>) / <span class="number">7.787</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.pow(var_Z, <span class="number">3</span>) &gt; <span class="number">0.008856</span>) &#123;</span><br><span class="line">    var_Z = <span class="built_in">Math</span>.pow(var_Z, <span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var_Z = (var_Z - <span class="number">16.0</span> / <span class="number">116.0</span>) / <span class="number">7.787</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ref_X = <span class="number">0.9505</span>;</span><br><span class="line">  <span class="keyword">const</span> ref_Y = <span class="number">1.000</span>;</span><br><span class="line">  <span class="keyword">const</span> ref_Z = <span class="number">1.089</span>;</span><br><span class="line">  xyz[<span class="number">0</span>] = ref_X * var_X; <span class="comment">// ref_X = 0.9505  Observer= 2 deg Illuminant= D65</span></span><br><span class="line">  xyz[<span class="number">1</span>] = ref_Y * var_Y; <span class="comment">// ref_Y = 1.000</span></span><br><span class="line">  xyz[<span class="number">2</span>] = ref_Z * var_Z; <span class="comment">// ref_Z = 1.089</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xyz2lab</span>(<span class="params">xyz, lab</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [x, y, z] = xyz;</span><br><span class="line">  <span class="keyword">const</span> ref_X = <span class="number">0.9505</span>;</span><br><span class="line">  <span class="keyword">const</span> ref_Y = <span class="number">1.000</span>;</span><br><span class="line">  <span class="keyword">const</span> ref_Z = <span class="number">1.089</span>;</span><br><span class="line">  <span class="keyword">let</span> var_X = x / ref_X;  <span class="comment">// ref_X = 0.9505  Observer= 2 deg, Illuminant= D65</span></span><br><span class="line">  <span class="keyword">let</span> var_Y = y / ref_Y;  <span class="comment">// ref_Y = 1.000</span></span><br><span class="line">  <span class="keyword">let</span> var_Z = z / ref_Z;  <span class="comment">// ref_Z = 1.089</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_X &gt; <span class="number">0.008856</span>) var_X = <span class="built_in">Math</span>.pow(var_X, <span class="number">1.0</span> / <span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">else</span> var_X = (<span class="number">7.787</span> * var_X) + (<span class="number">16.0</span> / <span class="number">116.0</span>);</span><br><span class="line">  <span class="keyword">if</span> (var_Y &gt; <span class="number">0.008856</span>) var_Y = <span class="built_in">Math</span>.pow(var_Y, <span class="number">1.0</span> / <span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">else</span> var_Y = (<span class="number">7.787</span> * var_Y) + (<span class="number">16.0</span> / <span class="number">116.0</span>);</span><br><span class="line">  <span class="keyword">if</span> (var_Z &gt; <span class="number">0.008856</span>) var_Z = <span class="built_in">Math</span>.pow(var_Z, <span class="number">1.0</span> / <span class="number">3.0</span>);</span><br><span class="line">  <span class="keyword">else</span> var_Z = (<span class="number">7.787</span> * var_Z) + (<span class="number">16.0</span> / <span class="number">116.0</span>);</span><br><span class="line"></span><br><span class="line">  lab[<span class="number">0</span>] = (<span class="number">116</span> * var_Y) - <span class="number">16</span>;</span><br><span class="line">  lab[<span class="number">1</span>] = <span class="number">500</span> * (var_X - var_Y);</span><br><span class="line">  lab[<span class="number">2</span>] = <span class="number">200</span> * (var_Y - var_Z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xyz2rgb</span>(<span class="params">xyz, rgb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [x, y, z] = xyz;</span><br><span class="line">  <span class="keyword">let</span> r = x * <span class="number">3.2406</span> + y * <span class="number">-1.5372</span> + z * <span class="number">-0.4986</span>;</span><br><span class="line">  <span class="keyword">let</span> g = x * <span class="number">-0.9689</span> + y * <span class="number">1.8758</span> + z * <span class="number">0.0415</span>;</span><br><span class="line">  <span class="keyword">let</span> b = x * <span class="number">0.0557</span> + y * <span class="number">-0.2040</span> + z * <span class="number">1.0570</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following performs a "gamma correction" specified by the sRGB color</span></span><br><span class="line">  <span class="comment">// space.  sRGB is defined by a canonical definition of a display monitor and</span></span><br><span class="line">  <span class="comment">// has been standardized by the International Electrotechnical Commission (IEC</span></span><br><span class="line">  <span class="comment">// 61966-2-1).  The nonlinearity of the correction is designed to make the</span></span><br><span class="line">  <span class="comment">// colors more perceptually uniform.  This color space has been adopted by</span></span><br><span class="line">  <span class="comment">// several applications including Adobe Photoshop and Microsoft Windows color</span></span><br><span class="line">  <span class="comment">// management.  OpenGL is agnostic on its RGB color space, but it is reasonable</span></span><br><span class="line">  <span class="comment">// to assume it is close to this one.</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; <span class="number">0.0031308</span>) r = <span class="number">1.055</span> * (<span class="built_in">Math</span>.pow(r, (<span class="number">1</span> / <span class="number">2.4</span>))) - <span class="number">0.055</span>;</span><br><span class="line">  <span class="keyword">else</span> r = <span class="number">12.92</span> * r;</span><br><span class="line">  <span class="keyword">if</span> (g &gt; <span class="number">0.0031308</span>) g = <span class="number">1.055</span> * (<span class="built_in">Math</span>.pow(g, (<span class="number">1</span> / <span class="number">2.4</span>))) - <span class="number">0.055</span>;</span><br><span class="line">  <span class="keyword">else</span> g = <span class="number">12.92</span> * g;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; <span class="number">0.0031308</span>) b = <span class="number">1.055</span> * (<span class="built_in">Math</span>.pow(b, (<span class="number">1</span> / <span class="number">2.4</span>))) - <span class="number">0.055</span>;</span><br><span class="line">  <span class="keyword">else</span> b = <span class="number">12.92</span> * b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clip colors. ideally we would do something that is perceptually closest</span></span><br><span class="line">  <span class="comment">// (since we can see colors outside of the display gamut), but this seems to</span></span><br><span class="line">  <span class="comment">// work well enough.</span></span><br><span class="line">  <span class="keyword">let</span> maxVal = r;</span><br><span class="line">  <span class="keyword">if</span> (maxVal &lt; g) maxVal = g;</span><br><span class="line">  <span class="keyword">if</span> (maxVal &lt; b) maxVal = b;</span><br><span class="line">  <span class="keyword">if</span> (maxVal &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    r /= maxVal;</span><br><span class="line">    g /= maxVal;</span><br><span class="line">    b /= maxVal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push values back to array</span></span><br><span class="line">  rgb[<span class="number">0</span>] = r;</span><br><span class="line">  rgb[<span class="number">1</span>] = g;</span><br><span class="line">  rgb[<span class="number">2</span>] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2xyz</span>(<span class="params">rgb, xyz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [r, g, b] = rgb;</span><br><span class="line">  <span class="comment">// The following performs a "gamma correction" specified by the sRGB color</span></span><br><span class="line">  <span class="comment">// space.  sRGB is defined by a canonical definition of a display monitor and</span></span><br><span class="line">  <span class="comment">// has been standardized by the International Electrotechnical Commission (IEC</span></span><br><span class="line">  <span class="comment">// 61966-2-1).  The nonlinearity of the correction is designed to make the</span></span><br><span class="line">  <span class="comment">// colors more perceptually uniform.  This color space has been adopted by</span></span><br><span class="line">  <span class="comment">// several applications including Adobe Photoshop and Microsoft Windows color</span></span><br><span class="line">  <span class="comment">// management.  OpenGL is agnostic on its RGB color space, but it is reasonable</span></span><br><span class="line">  <span class="comment">// to assume it is close to this one.</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; <span class="number">0.04045</span>) r = <span class="built_in">Math</span>.pow((r + <span class="number">0.055</span>) / <span class="number">1.055</span>, <span class="number">2.4</span>);</span><br><span class="line">  <span class="keyword">else</span> r = r / <span class="number">12.92</span>;</span><br><span class="line">  <span class="keyword">if</span> (g &gt; <span class="number">0.04045</span>) g = <span class="built_in">Math</span>.pow((g + <span class="number">0.055</span>) / <span class="number">1.055</span>, <span class="number">2.4</span>);</span><br><span class="line">  <span class="keyword">else</span> g = g / <span class="number">12.92</span>;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; <span class="number">0.04045</span>) b = <span class="built_in">Math</span>.pow((b + <span class="number">0.055</span>) / <span class="number">1.055</span>, <span class="number">2.4</span>);</span><br><span class="line">  <span class="keyword">else</span> b = b / <span class="number">12.92</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Observer. = 2 deg, Illuminant = D65</span></span><br><span class="line">  xyz[<span class="number">0</span>] = r * <span class="number">0.4124</span> + g * <span class="number">0.3576</span> + b * <span class="number">0.1805</span>;</span><br><span class="line">  xyz[<span class="number">1</span>] = r * <span class="number">0.2126</span> + g * <span class="number">0.7152</span> + b * <span class="number">0.0722</span>;</span><br><span class="line">  xyz[<span class="number">2</span>] = r * <span class="number">0.0193</span> + g * <span class="number">0.1192</span> + b * <span class="number">0.9505</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2lab</span>(<span class="params">rgb, lab</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xyz = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">  rgb2xyz(rgb, xyz);</span><br><span class="line">  xyz2lab(xyz, lab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LabToRGB</span>(<span class="params">lab, rgb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xyz = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">  lab2xyz(lab, xyz);</span><br><span class="line">  xyz2rgb(xyz, rgb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uninitializeBounds</span>(<span class="params">bounds</span>) </span>&#123;</span><br><span class="line">  bounds[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  bounds[<span class="number">1</span>] = <span class="number">-1.0</span>;</span><br><span class="line">  bounds[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">  bounds[<span class="number">3</span>] = <span class="number">-1.0</span>;</span><br><span class="line">  bounds[<span class="number">4</span>] = <span class="number">1.0</span>;</span><br><span class="line">  bounds[<span class="number">5</span>] = <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areBoundsInitialized</span>(<span class="params">bounds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(bounds[<span class="number">1</span>] - bounds[<span class="number">0</span>] &lt; <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clampValue</span>(<span class="params">value, minValue, maxValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clampAndNormalizeValue</span>(<span class="params">value, range</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (range[<span class="number">0</span>] !== range[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="comment">// clamp</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; range[<span class="number">0</span>]) &#123;</span><br><span class="line">      result = range[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; range[<span class="number">1</span>]) &#123;</span><br><span class="line">        result = range[<span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// normalize</span></span><br><span class="line">    result = (result - range[<span class="number">0</span>]) / (range[<span class="number">1</span>] - range[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScalarTypeFittingRange = notImplemented(<span class="string">'GetScalarTypeFittingRange'</span>);</span><br><span class="line"><span class="keyword">const</span> getAdjustedScalarRange = notImplemented(<span class="string">'GetAdjustedScalarRange'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extentIsWithinOtherExtent</span>(<span class="params">extent1, extent2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!extent1 || !extent2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (extent1[i] &lt; extent2[i] || extent1[i] &gt; extent2[i + <span class="number">1</span>] ||</span><br><span class="line">      extent1[i + <span class="number">1</span>] &lt; extent2[i] || extent1[i + <span class="number">1</span>] &gt; extent2[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boundsIsWithinOtherBounds</span>(<span class="params">bounds1_6, bounds2_6, delta_3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!bounds1_6 || !bounds2_6) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bounds1_6[i] + delta_3[i / <span class="number">2</span>] &lt; bounds2_6[i]</span><br><span class="line">      || bounds1_6[i] - delta_3[i / <span class="number">2</span>] &gt; bounds2_6[i + <span class="number">1</span>]</span><br><span class="line">      || bounds1_6[i + <span class="number">1</span>] + delta_3[i / <span class="number">2</span>] &lt; bounds2_6[i]</span><br><span class="line">      || bounds1_6[i + <span class="number">1</span>] - delta_3[i / <span class="number">2</span>] &gt; bounds2_6[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointIsWithinBounds</span>(<span class="params">point_3, bounds_6, delta_3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!point_3 || !bounds_6 || !delta_3) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (point_3[i] + delta_3[i] &lt; bounds_6[<span class="number">2</span> * i] || point_3[i] - delta_3[i] &gt; bounds_6[<span class="number">2</span> * i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solve3PointCircle</span>(<span class="params">p1, p2, p3, center</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v21 = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> v32 = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> v13 = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> v12 = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> v23 = createArray(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> v31 = createArray(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    v21[i] = p1[i] - p2[i];</span><br><span class="line">    v32[i] = p2[i] - p3[i];</span><br><span class="line">    v13[i] = p3[i] - p1[i];</span><br><span class="line">    v12[i] = -v21[i];</span><br><span class="line">    v23[i] = -v32[i];</span><br><span class="line">    v31[i] = -v13[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> norm12 = norm(v12);</span><br><span class="line">  <span class="keyword">const</span> norm23 = norm(v23);</span><br><span class="line">  <span class="keyword">const</span> norm13 = norm(v13);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> crossv21v32 = createArray(<span class="number">3</span>);</span><br><span class="line">  cross(v21, v32, crossv21v32);</span><br><span class="line">  <span class="keyword">const</span> normCross = norm(crossv21v32);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> radius = (norm12 * norm23 * norm13) / (<span class="number">2</span> * normCross);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> normCross22 = <span class="number">2</span> * normCross * normCross;</span><br><span class="line">  <span class="keyword">const</span> alpha = ((norm23 * norm23) * dot(v21, v31)) / normCross22;</span><br><span class="line">  <span class="keyword">const</span> beta = ((norm13 * norm13) * dot(v12, v32)) / normCross22;</span><br><span class="line">  <span class="keyword">const</span> gamma = ((norm12 * norm12) * dot(v13, v23)) / normCross22;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    center[i] = alpha * p1[i] + beta * p2[i] + gamma * p3[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inf = <span class="literal">Infinity</span>;</span><br><span class="line"><span class="keyword">const</span> negInf = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isInf = value =&gt; !<span class="built_in">Number</span>.isFinite(value);</span><br><span class="line"><span class="keyword">const</span> isNan = <span class="built_in">Number</span>.isNaN;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">isFinite</span> = <span class="built_in">Number</span>.isFinite;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript - add-on ----------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUninitializedBouds</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat([</span><br><span class="line">    <span class="built_in">Number</span>.MAX_VALUE, <span class="built_in">Number</span>.MIN_VALUE, <span class="comment">// X</span></span><br><span class="line">    <span class="built_in">Number</span>.MAX_VALUE, <span class="built_in">Number</span>.MIN_VALUE, <span class="comment">// Y</span></span><br><span class="line">    <span class="built_in">Number</span>.MAX_VALUE, <span class="built_in">Number</span>.MIN_VALUE, <span class="comment">// Z</span></span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Only Static API</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Pi,</span><br><span class="line">  radiansFromDegrees,</span><br><span class="line">  degreesFromRadians,</span><br><span class="line">  round,</span><br><span class="line">  floor,</span><br><span class="line">  ceil,</span><br><span class="line">  ceilLog2,</span><br><span class="line">  min,</span><br><span class="line">  max,</span><br><span class="line">  isPowerOfTwo,</span><br><span class="line">  nearestPowerOfTwo,</span><br><span class="line">  factorial,</span><br><span class="line">  binomial,</span><br><span class="line">  beginCombination,</span><br><span class="line">  nextCombination,</span><br><span class="line">  randomSeed,</span><br><span class="line">  getSeed,</span><br><span class="line">  random,</span><br><span class="line">  gaussian,</span><br><span class="line">  add,</span><br><span class="line">  subtract,</span><br><span class="line">  multiplyScalar,</span><br><span class="line">  multiplyScalar2D,</span><br><span class="line">  dot,</span><br><span class="line">  outer,</span><br><span class="line">  cross,</span><br><span class="line">  norm,</span><br><span class="line">  normalize,</span><br><span class="line">  perpendiculars,</span><br><span class="line">  projectVector,</span><br><span class="line">  projectVector2D,</span><br><span class="line">  distance2BetweenPoints,</span><br><span class="line">  angleBetweenVectors,</span><br><span class="line">  gaussianAmplitude,</span><br><span class="line">  gaussianWeight,</span><br><span class="line">  dot2D,</span><br><span class="line">  outer2D,</span><br><span class="line">  norm2D,</span><br><span class="line">  normalize2D,</span><br><span class="line">  determinant2x2,</span><br><span class="line">  LUFactor3x3,</span><br><span class="line">  LUSolve3x3,</span><br><span class="line">  linearSolve3x3,</span><br><span class="line">  multiply3x3_vect3,</span><br><span class="line">  multiply3x3_mat3,</span><br><span class="line">  multiplyMatrix,</span><br><span class="line">  transpose3x3,</span><br><span class="line">  invert3x3,</span><br><span class="line">  identity3x3,</span><br><span class="line">  determinant3x3,</span><br><span class="line">  quaternionToMatrix3x3,</span><br><span class="line">  matrix3x3ToQuaternion,</span><br><span class="line">  multiplyQuaternion,</span><br><span class="line">  orthogonalize3x3,</span><br><span class="line">  diagonalize3x3,</span><br><span class="line">  singularValueDecomposition3x3,</span><br><span class="line">  solveLinearSystem,</span><br><span class="line">  invertMatrix,</span><br><span class="line">  luFactorLinearSystem,</span><br><span class="line">  luSolveLinearSystem,</span><br><span class="line">  estimateMatrixCondition,</span><br><span class="line">  jacobi,</span><br><span class="line">  jacobiN,</span><br><span class="line">  solveHomogeneousLeastSquares,</span><br><span class="line">  solveLeastSquares,</span><br><span class="line">  rgb2hsv,</span><br><span class="line">  hsv2rgb,</span><br><span class="line">  lab2xyz,</span><br><span class="line">  xyz2lab,</span><br><span class="line">  xyz2rgb,</span><br><span class="line">  rgb2xyz,</span><br><span class="line">  rgb2lab,</span><br><span class="line">  LabToRGB,</span><br><span class="line">  uninitializeBounds,</span><br><span class="line">  areBoundsInitialized,</span><br><span class="line">  clampValue,</span><br><span class="line">  clampAndNormalizeValue,</span><br><span class="line">  getScalarTypeFittingRange,</span><br><span class="line">  getAdjustedScalarRange,</span><br><span class="line">  extentIsWithinOtherExtent,</span><br><span class="line">  boundsIsWithinOtherBounds,</span><br><span class="line">  pointIsWithinBounds,</span><br><span class="line">  solve3PointCircle,</span><br><span class="line">  inf,</span><br><span class="line">  negInf,</span><br><span class="line">  isInf,</span><br><span class="line">  isNan,</span><br><span class="line">  <span class="built_in">isFinite</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JS add-on</span></span><br><span class="line">  createUninitializedBouds,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2016-05-14T05:25:44.098Z" itemprop="dateModified">Last updated: 2016-05-14</time>
                <a href="LookupTable.html" class="article-footer-prev" title="LookupTable"><i class="fa fa-chevron-left"></i><span>Prev</span></a><a href="BoundingBox.html" class="article-footer-next" title="BoundingBox"><span>Next</span><i class="fa fa-chevron-right"></i></a>
              </footer>
              
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">Contents</strong>
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pi-Math-PI"><span class="toc-text">Pi() : Math.PI;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#radiansFromDegrees-degree-radian"><span class="toc-text">radiansFromDegrees(degree) : radian</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#degreesFromRadians-radian-degree"><span class="toc-text">degreesFromRadians(radian) : degree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#round-float-int"><span class="toc-text">round(float): int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floor-float-int"><span class="toc-text">floor(float) : int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ceil-float-int"><span class="toc-text">ceil(float) : int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ceilLog2"><span class="toc-text">ceilLog2()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-a-b"><span class="toc-text">min(a, b)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max-a-b"><span class="toc-text">max(a, b)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isPowerOfTwo-number-Boolean"><span class="toc-text">isPowerOfTwo(number) : Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nearestPowerOfTwo-number-int"><span class="toc-text">nearestPowerOfTwo(number) : int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#factorial-n-number"><span class="toc-text">factorial(n) : number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binomial-m-n-int"><span class="toc-text">binomial(m, n) : int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beginCombination-m-n-Array-or-null"><span class="toc-text">beginCombination(m, n) : Array or null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextCombination-m-n-r-Boolean"><span class="toc-text">nextCombination(m, n, r) : Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#randomSeed"><span class="toc-text">randomSeed()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSeed"><span class="toc-text">getSeed()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random-minValue-0-maxValue-1-Number"><span class="toc-text">random(minValue = 0, maxValue = 1) : Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gaussian"><span class="toc-text">gaussian()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-a-b-out"><span class="toc-text">add(a, b, out)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subtract-a-b-out"><span class="toc-text">subtract(a, b, out)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiplyScalar-vec-scalar"><span class="toc-text">multiplyScalar(vec, scalar) {</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Source"><span class="toc-text">Source</span></a>
              <a href="#" id="article-toc-top">Back to Top</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner"><strong class="sidebar-title">Common/Core</strong><a href="DataArray.html" class="sidebar-link">DataArray</a><a href="DynamicTypedArray.html" class="sidebar-link">DynamicTypedArray</a><a href="Endian.html" class="sidebar-link">Endian</a><a href="LookupTable.html" class="sidebar-link">LookupTable</a><a href="Math.html" class="sidebar-link current">Math</a><strong class="sidebar-title">Common/DataModel</strong><a href="BoundingBox.html" class="sidebar-link">BoundingBox</a><a href="DataSet.html" class="sidebar-link">DataSet</a><a href="DataSetAttributes.html" class="sidebar-link">DataSetAttributes</a><a href="Plane.html" class="sidebar-link">Plane</a><strong class="sidebar-title">Common/System</strong><a href="TimerLog.html" class="sidebar-link">TimerLog</a><strong class="sidebar-title">Filters/Sources</strong><a href="ConeSource.html" class="sidebar-link">ConeSource</a><a href="SphereSource.html" class="sidebar-link">SphereSource</a><strong class="sidebar-title">IO/Core</strong><a href="HttpDataSetReader.html" class="sidebar-link">HttpDataSetReader</a><strong class="sidebar-title">Rendering/Core</strong><a href="Actor.html" class="sidebar-link">Actor</a><a href="Camera.html" class="sidebar-link">Camera</a><a href="Light.html" class="sidebar-link">Light</a><a href="Mapper.html" class="sidebar-link">Mapper</a><a href="Prop.html" class="sidebar-link">Prop</a><a href="Prop3D.html" class="sidebar-link">Prop3D</a><a href="Property.html" class="sidebar-link">Property</a><a href="RenderWindow.html" class="sidebar-link">RenderWindow</a><a href="Renderer.html" class="sidebar-link">Renderer</a><a href="Viewport.html" class="sidebar-link">Viewport</a><strong class="sidebar-title">Rendering/OpenGL</strong><a href="Actor.html" class="sidebar-link">Actor</a><a href="BufferObject.html" class="sidebar-link">BufferObject</a><a href="Camera.html" class="sidebar-link">Camera</a><a href="Helper.html" class="sidebar-link">Helper</a><a href="IndexBufferObject.html" class="sidebar-link">IndexBufferObject</a><a href="PolyDataMapper.html" class="sidebar-link">PolyDataMapper</a><a href="RenderWindow.html" class="sidebar-link">RenderWindow</a><a href="Renderer.html" class="sidebar-link">Renderer</a><a href="Shader.html" class="sidebar-link">Shader</a><a href="ShaderCache.html" class="sidebar-link">ShaderCache</a><a href="ShaderProgram.html" class="sidebar-link">ShaderProgram</a><a href="VertexArrayObject.html" class="sidebar-link">VertexArrayObject</a><a href="VertexBufferObject.html" class="sidebar-link">VertexBufferObject</a><a href="ViewNodeFactory.html" class="sidebar-link">ViewNodeFactory</a><a href="glsl.html" class="sidebar-link">glsl</a><strong class="sidebar-title">Rendering/SceneGraph</strong><a href="ViewNode.html" class="sidebar-link">ViewNode</a><a href="ViewNodeFactory.html" class="sidebar-link">ViewNodeFactory</a></div>
</aside>
    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2016 <a href="http://www.kitware.com" target="_blank">Kitware Inc.</a>
    </div>
    <div id="footer-links">
      <a href="https://github.com/kitware/vtk-js" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/vtk-js/docs/" class="mobile-nav-link">Docs</a><a href="/vtk-js/api/" class="mobile-nav-link">API</a><a href="/vtk-js/examples/" class="mobile-nav-link">Examples</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/kitware/vtk-js" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">Common/Core</strong><a href="DataArray.html" class="mobile-nav-link">DataArray</a><a href="DynamicTypedArray.html" class="mobile-nav-link">DynamicTypedArray</a><a href="Endian.html" class="mobile-nav-link">Endian</a><a href="LookupTable.html" class="mobile-nav-link">LookupTable</a><a href="Math.html" class="mobile-nav-link current">Math</a><strong class="mobile-nav-title">Common/DataModel</strong><a href="BoundingBox.html" class="mobile-nav-link">BoundingBox</a><a href="DataSet.html" class="mobile-nav-link">DataSet</a><a href="DataSetAttributes.html" class="mobile-nav-link">DataSetAttributes</a><a href="Plane.html" class="mobile-nav-link">Plane</a><strong class="mobile-nav-title">Common/System</strong><a href="TimerLog.html" class="mobile-nav-link">TimerLog</a><strong class="mobile-nav-title">Filters/Sources</strong><a href="ConeSource.html" class="mobile-nav-link">ConeSource</a><a href="SphereSource.html" class="mobile-nav-link">SphereSource</a><strong class="mobile-nav-title">IO/Core</strong><a href="HttpDataSetReader.html" class="mobile-nav-link">HttpDataSetReader</a><strong class="mobile-nav-title">Rendering/Core</strong><a href="Actor.html" class="mobile-nav-link">Actor</a><a href="Camera.html" class="mobile-nav-link">Camera</a><a href="Light.html" class="mobile-nav-link">Light</a><a href="Mapper.html" class="mobile-nav-link">Mapper</a><a href="Prop.html" class="mobile-nav-link">Prop</a><a href="Prop3D.html" class="mobile-nav-link">Prop3D</a><a href="Property.html" class="mobile-nav-link">Property</a><a href="RenderWindow.html" class="mobile-nav-link">RenderWindow</a><a href="Renderer.html" class="mobile-nav-link">Renderer</a><a href="Viewport.html" class="mobile-nav-link">Viewport</a><strong class="mobile-nav-title">Rendering/OpenGL</strong><a href="Actor.html" class="mobile-nav-link">Actor</a><a href="BufferObject.html" class="mobile-nav-link">BufferObject</a><a href="Camera.html" class="mobile-nav-link">Camera</a><a href="Helper.html" class="mobile-nav-link">Helper</a><a href="IndexBufferObject.html" class="mobile-nav-link">IndexBufferObject</a><a href="PolyDataMapper.html" class="mobile-nav-link">PolyDataMapper</a><a href="RenderWindow.html" class="mobile-nav-link">RenderWindow</a><a href="Renderer.html" class="mobile-nav-link">Renderer</a><a href="Shader.html" class="mobile-nav-link">Shader</a><a href="ShaderCache.html" class="mobile-nav-link">ShaderCache</a><a href="ShaderProgram.html" class="mobile-nav-link">ShaderProgram</a><a href="VertexArrayObject.html" class="mobile-nav-link">VertexArrayObject</a><a href="VertexBufferObject.html" class="mobile-nav-link">VertexBufferObject</a><a href="ViewNodeFactory.html" class="mobile-nav-link">ViewNodeFactory</a><a href="glsl.html" class="mobile-nav-link">glsl</a><strong class="mobile-nav-title">Rendering/SceneGraph</strong><a href="ViewNode.html" class="mobile-nav-link">ViewNode</a><a href="ViewNodeFactory.html" class="mobile-nav-link">ViewNodeFactory</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>English</span></span>
    <select id="mobile-lang-select" data-canonical="api/Math.html">
      
        <option value="en" selected>English</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- build:js build/js/main.js -->
<script src="/vtk-js/js/lang_select.js"></script>
<script src="/vtk-js/js/toc.js"></script>
<script src="/vtk-js/js/mobile_nav.js"></script>
<!-- endbuild -->
<script src="https://cdn.jsdelivr.net/retinajs/1.3.0/retina.min.js" async></script>



</body>
</html>